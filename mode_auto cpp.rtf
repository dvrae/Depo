{\rtf1\adeflang1025\ansi\ansicpg1252\uc1\adeff31507\deff0\stshfdbch31506\stshfloch31506\stshfhich31506\stshfbi31507\deflang1033\deflangfe1033\themelang9226\themelangfe0\themelangcs0{\fonttbl{\f0\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f34\fbidi \froman\fcharset0\fprq2{\*\panose 02040503050406030204}Cambria Math;}
{\f37\fbidi \fswiss\fcharset0\fprq2{\*\panose 020f0502020204030204}Calibri;}{\flomajor\f31500\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\fdbmajor\f31501\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\fhimajor\f31502\fbidi \fswiss\fcharset0\fprq2{\*\panose 020f0302020204030204}Calibri Light;}
{\fbimajor\f31503\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\flominor\f31504\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\fdbminor\f31505\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\fhiminor\f31506\fbidi \fswiss\fcharset0\fprq2{\*\panose 020f0502020204030204}Calibri;}
{\fbiminor\f31507\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f43\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}{\f44\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}
{\f46\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}{\f47\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}{\f48\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f49\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}
{\f50\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}{\f51\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\f413\fbidi \fswiss\fcharset238\fprq2 Calibri CE;}{\f414\fbidi \fswiss\fcharset204\fprq2 Calibri Cyr;}
{\f416\fbidi \fswiss\fcharset161\fprq2 Calibri Greek;}{\f417\fbidi \fswiss\fcharset162\fprq2 Calibri Tur;}{\f418\fbidi \fswiss\fcharset177\fprq2 Calibri (Hebrew);}{\f419\fbidi \fswiss\fcharset178\fprq2 Calibri (Arabic);}
{\f420\fbidi \fswiss\fcharset186\fprq2 Calibri Baltic;}{\f421\fbidi \fswiss\fcharset163\fprq2 Calibri (Vietnamese);}{\flomajor\f31508\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}
{\flomajor\f31509\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}{\flomajor\f31511\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}{\flomajor\f31512\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}
{\flomajor\f31513\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\flomajor\f31514\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}{\flomajor\f31515\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}
{\flomajor\f31516\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\fdbmajor\f31518\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}{\fdbmajor\f31519\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}
{\fdbmajor\f31521\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}{\fdbmajor\f31522\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}{\fdbmajor\f31523\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}
{\fdbmajor\f31524\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}{\fdbmajor\f31525\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}{\fdbmajor\f31526\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}
{\fhimajor\f31528\fbidi \fswiss\fcharset238\fprq2 Calibri Light CE;}{\fhimajor\f31529\fbidi \fswiss\fcharset204\fprq2 Calibri Light Cyr;}{\fhimajor\f31531\fbidi \fswiss\fcharset161\fprq2 Calibri Light Greek;}
{\fhimajor\f31532\fbidi \fswiss\fcharset162\fprq2 Calibri Light Tur;}{\fhimajor\f31533\fbidi \fswiss\fcharset177\fprq2 Calibri Light (Hebrew);}{\fhimajor\f31534\fbidi \fswiss\fcharset178\fprq2 Calibri Light (Arabic);}
{\fhimajor\f31535\fbidi \fswiss\fcharset186\fprq2 Calibri Light Baltic;}{\fhimajor\f31536\fbidi \fswiss\fcharset163\fprq2 Calibri Light (Vietnamese);}{\fbimajor\f31538\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}
{\fbimajor\f31539\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}{\fbimajor\f31541\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}{\fbimajor\f31542\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}
{\fbimajor\f31543\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\fbimajor\f31544\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}{\fbimajor\f31545\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}
{\fbimajor\f31546\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\flominor\f31548\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}{\flominor\f31549\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}
{\flominor\f31551\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}{\flominor\f31552\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}{\flominor\f31553\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}
{\flominor\f31554\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}{\flominor\f31555\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}{\flominor\f31556\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}
{\fdbminor\f31558\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}{\fdbminor\f31559\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}{\fdbminor\f31561\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}
{\fdbminor\f31562\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}{\fdbminor\f31563\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\fdbminor\f31564\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}
{\fdbminor\f31565\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}{\fdbminor\f31566\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\fhiminor\f31568\fbidi \fswiss\fcharset238\fprq2 Calibri CE;}
{\fhiminor\f31569\fbidi \fswiss\fcharset204\fprq2 Calibri Cyr;}{\fhiminor\f31571\fbidi \fswiss\fcharset161\fprq2 Calibri Greek;}{\fhiminor\f31572\fbidi \fswiss\fcharset162\fprq2 Calibri Tur;}
{\fhiminor\f31573\fbidi \fswiss\fcharset177\fprq2 Calibri (Hebrew);}{\fhiminor\f31574\fbidi \fswiss\fcharset178\fprq2 Calibri (Arabic);}{\fhiminor\f31575\fbidi \fswiss\fcharset186\fprq2 Calibri Baltic;}
{\fhiminor\f31576\fbidi \fswiss\fcharset163\fprq2 Calibri (Vietnamese);}{\fbiminor\f31578\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}{\fbiminor\f31579\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}
{\fbiminor\f31581\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}{\fbiminor\f31582\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}{\fbiminor\f31583\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}
{\fbiminor\f31584\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}{\fbiminor\f31585\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}{\fbiminor\f31586\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;
\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green0\blue0;\red0\green0\blue0;}{\*\defchp \f31506\fs22\lang9226\langfe1033\langnp9226 }{\*\defpap \ql \li0\ri0\sa160\sl259\slmult1
\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 }\noqfpromote {\stylesheet{\ql \li0\ri0\sa160\sl259\slmult1\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \rtlch\fcs1 \af31507\afs22\alang1025 
\ltrch\fcs0 \f31506\fs22\lang9226\langfe1033\cgrid\langnp9226\langfenp1033 \snext0 \sqformat \spriority0 Normal;}{\*\cs10 \additive \ssemihidden \sunhideused \spriority1 Default Paragraph Font;}{\*
\ts11\tsrowd\trftsWidthB3\trpaddl108\trpaddr108\trpaddfl3\trpaddft3\trpaddfb3\trpaddfr3\trcbpat1\trcfpat1\tblind0\tblindtype3\tsvertalt\tsbrdrt\tsbrdrl\tsbrdrb\tsbrdrr\tsbrdrdgl\tsbrdrdgr\tsbrdrh\tsbrdrv \ql \li0\ri0\sa160\sl259\slmult1
\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \rtlch\fcs1 \af31507\afs22\alang1025 \ltrch\fcs0 \f31506\fs22\lang9226\langfe1033\cgrid\langnp9226\langfenp1033 \snext11 \ssemihidden \sunhideused Normal Table;}}{\*\revtbl {Unknown;}}{\*\pgptbl {\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp0\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp106\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp
\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}{\pgp\ipgp158\itap0\li0\ri0\sb0\sa0}}{\*\rsidtbl \rsid7607385\rsid15410912}{\mmathPr\mmathFont34\mbrkBin0\mbrkBinSub0\msmallFrac0\mdispDef1\mlMargin0
\mrMargin0\mdefJc1\mwrapIndent1440\mintLim0\mnaryLim1}{\info{\author Andres Ardila Sedano}{\operator ALEJANDRO TACHE}{\creatim\yr2019\mo2\dy12\hr21\min31}{\revtim\yr2019\mo2\dy12\hr21\min31}{\version2}{\edmins1}{\nofpages68}{\nofwords10072}
{\nofchars57416}{\nofcharsws67354}{\vern97}}{\*\xmlnstbl {\xmlns1 http://schemas.microsoft.com/office/word/2003/wordml}}\paperw12240\paperh15840\margl1701\margr1701\margt1417\margb1417\gutter0\ltrsect 
\deftab708\widowctrl\ftnbj\aenddoc\hyphhotz425\trackmoves0\trackformatting1\donotembedsysfont1\relyonvml0\donotembedlingdata0\grfdocevents0\validatexml1\showplaceholdtext0\ignoremixedcontent0\saveinvalidxml0
\showxmlerrors1\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\formshade\horzdoc\dgmargin\dghspace180\dgvspace180\dghorigin1701\dgvorigin1417\dghshow1\dgvshow1
\jexpand\viewkind1\viewscale93\pgbrdrhead\pgbrdrfoot\splytwnine\ftnlytwnine\htmautsp\nolnhtadjtbl\useltbaln\alntblind\lytcalctblwd\lyttblrtgr\lnbrkrule\nobrkwrptbl\snaptogridincell\allowfieldendsel\wrppunct
\asianbrkrule\rsidroot15410912\newtblstyruls\nogrowautofit\usenormstyforlist\noindnmbrts\felnbrelev\nocxsptable\indrlsweleven\noafcnsttbl\afelev\utinl\hwelev\spltpgpar\notcvasp\notbrkcnstfrctbl\notvatxbx\krnprsnet\cachedcolbal \nouicompat \fet0
{\*\wgrffmtfilter 2450}\nofeaturethrottle1\ilfomacatclnup0\ltrpar \sectd \ltrsect\linex0\headery708\footery708\colsx708\endnhere\sectlinegrid360\sectdefaultcl\sftnbj {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl2
\pnucltr\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang {\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl6
\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang 
{\pntxtb (}{\pntxta )}}\pard\plain \ltrpar\ql \li0\ri0\sa160\sl259\slmult1\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid15410912 \rtlch\fcs1 \af31507\afs22\alang1025 \ltrch\fcs0 
\f31506\fs22\lang9226\langfe1033\cgrid\langnp9226\langfenp1033 {\rtlch\fcs1 \af31507 \ltrch\fcs0 \b\lang1033\langfe1033\highlight4\langnp1033\insrsid15410912\charrsid7607385 mode_auto.cpp}{\rtlch\fcs1 \af31507 \ltrch\fcs0 
\b\lang1033\langfe1033\langnp1033\insrsid15410912\charrsid15410912 
\par }{\rtlch\fcs1 \af31507 \ltrch\fcs0 \lang1033\langfe1033\langnp1033\insrsid15410912 
\par }{\rtlch\fcs1 \af31507 \ltrch\fcs0 \lang1033\langfe1033\langnp1033\insrsid15410912\charrsid15410912 #include "Copter.h"
\par 
\par #if MODE_AUTO_ENABLED == ENABLED
\par 
\par /*
\par  * Init and run calls for auto flight mode
\par  *
\par  * This file contains the implementation for Land, Waypoint navigation and Takeoff from Auto mode
\par  * Command execution code (i.e. command_logic.pde) should:
\par  *      a) switch to Auto flight mode with set_mode() function.  This will cause auto_init to be called
\par  *      b) call one of the three auto initialisation functions: auto_wp_start(), auto_takeoff_start(), auto_land_start()
\par  *      c) call one of the verify functions auto_wp_verify(), auto_takeoff_verify, auto_land_verify repeated to check if the command has completed
\par  * The main loop (i.e. fast loop) will call update_flight_modes() which will in turn call auto_run() which, based upon the auto_mode variable will call
\par  *      correct auto_wp_run, auto_takeoff_run or auto_land_run to actually implement the feature
\par  */
\par 
\par /*
\par  *  While in the auto flight mode, navigation or do/now commands can be run.
\par  *  Code in this file implements the navigation commands
\par  */
\par 
\par // auto_init - initialise auto controller
\par bool Copter::ModeAuto::init(bool ignore_checks)
\par \{
\par     if ((copter.position_ok() && copter.mission.num_commands() > 1) || ignore_checks) \{
\par         _mode = Auto_Loiter;
\par 
\par         // reject switching to auto mode if landed with motors armed but first command is not a takeoff (reduce chance of flips)
\par         if (motors->armed() && ap.land_complete && !copter.mission.starts_with_takeoff_cmd()) \{
\par             gcs().send_text(MAV_SEVERITY_CRITICAL, "Auto: Missing Takeoff Cmd");
\par             return false;
\par         \}
\par 
\par         // stop ROI from carrying over from previous runs of the mission
\par         // To-Do: reset the yaw as part of auto_wp_start when the previous command was not a wp command to remove the need for this special ROI check
\par         if (auto_yaw.mode() == AUTO_YAW_ROI) \{
\par             auto_yaw.set_mode(AUTO_YAW_HOLD);
\par         \}
\par 
\par         // initialise waypoint and spline controller
\par         wp_nav->wp_and_spline_init();
\par 
\par         // clear guided limits
\par         copter.mode_guided.limit_clear();
\par 
\par         // start/resume the mission (based on MIS_RESTART parameter)
\par         copter.mission.start_or_resume();
\par         return true;
\par     \} else \{
\par         return false;
\par     \}
\par \}
\par 
\par // auto_run - runs the auto controller
\par //      should be called at 100hz or more
\par //      relies on run_autopilot being called at 10hz which handles decision making and non-navigation related commands
\par void Copter::ModeAuto::run()
\par \{
\par \tab // call the correct auto controller
\par     switch (_mode) \{
\par 
\par     case Auto_TakeOff:
\par         takeoff_run();
\par         break;
\par 
\par     case Auto_WP:
\par     case Auto_CircleMoveToEdge:
\par         wp_run();
\par         break;
\par 
\par     case Auto_Land:
\par         land_run();
\par         break;
\par 
\par     case Auto_RTL:
\par         rtl_run();
\par         break;
\par 
\par     case Auto_Circle:
\par         circle_run();
\par         break;
\par 
\par     case Auto_Spline:
\par         spline_run();
\par         break;
\par 
\par     case Auto_NavGuided:
\par #if NAV_GUIDED == ENABLED
\par         nav_guided_run();
\par #endif
\par         break;
\par 
\par     case Auto_Loiter:
\par         loiter_run();
\par         break;
\par 
\par     case Auto_NavPayloadPlace:
\par         payload_place_run();
\par         break;
\par     \}
\par \}
\par 
\par // auto_loiter_start - initialises loitering in auto mode
\par //  returns success/failure because this can be called by exit_mission
\par bool Copter::ModeAuto::loiter_start()
\par \{
\par     // return failure if GPS is bad
\par     if (!copter.position_ok()) \{
\par         return false;
\par     \}
\par     _mode = Auto_Loiter;
\par 
\par     // calculate stopping point
\par     Vector3f stopping_point;
\par     wp_nav->get_wp_stopping_point(stopping_point);
\par 
\par     // initialise waypoint controller target to stopping point
\par     wp_nav->set_wp_destination(stopping_point);
\par 
\par     // hold yaw at current heading
\par     auto_yaw.set_mode(AUTO_YAW_HOLD);
\par 
\par     return true;
\par \}
\par 
\par // auto_rtl_start - initialises RTL in AUTO flight mode
\par void Copter::ModeAuto::rtl_start()
\par \{
\par     _mode = Auto_RTL;
\par 
\par     // call regular rtl flight mode initialisation and ask it to ignore checks
\par     copter.mode_rtl.init(true);
\par \}
\par 
\par // auto_takeoff_start - initialises waypoint controller to implement take-off
\par void Copter::ModeAuto::takeoff_start(const Location& dest_loc)
\par \{
\par     _mode = Auto_TakeOff;
\par 
\par     // convert location to class
\par     Location_Class dest(dest_loc);
\par 
\par     // set horizontal target
\par     dest.lat = copter.current_loc.lat;
\par     dest.lng = copter.current_loc.lng;
\par 
\par     // get altitude target
\par     int32_t alt_target;
\par     if (!dest.get_alt_cm(Location_Class::ALT_FRAME_ABOVE_HOME, alt_target)) \{
\par         // this failure could only happen if take-off alt was specified as an alt-above terrain and we have no terrain data
\par         copter.Log_Write_Error(ERROR_SUBSYSTEM_TERRAIN, ERROR_CODE_MISSING_TERRAIN_DATA);
\par         // fall back to altitude above current altitude
\par         alt_target = copter.current_loc.alt + dest.alt;
\par     \}
\par 
\par     // sanity check target
\par     if (alt_target < copter.current_loc.alt) \{
\par         dest.set_alt_cm(copter.current_loc.alt, Location_Class::ALT_FRAME_ABOVE_HOME);
\par     \}
\par     // Note: if taking off from below home this could cause a climb to an unexpectedly high altitude
\par     if (alt_target < 100) \{
\par         dest.set_alt_cm(100, Location_Class::ALT_FRAME_ABOVE_HOME);
\par     \}
\par 
\par     // set waypoint controller target
\par     if (!wp_nav->set_wp_destination(dest)) \{
\par         // failure to set destination can only be because of missing terrain data
\par         copter.failsafe_terrain_on_event();
\par         return;
\par     \}
\par 
\par     // initialise yaw
\par     auto_yaw.set_mode(AUTO_YAW_HOLD);
\par 
\par     // clear i term when we're taking off
\par     set_throttle_takeoff();
\par 
\par     // get initial alt for WP_NAVALT_MIN
\par     copter.auto_takeoff_set_start_alt();
\par \}
\par 
\par // auto_wp_start - initialises waypoint controller to implement flying to a particular destination
\par void Copter::ModeAuto::wp_start(const Vector3f& destination)
\par \{
\par     _mode = Auto_WP;
\par 
\par     // initialise wpnav (no need to check return status because terrain data is not used)
\par     wp_nav->set_wp_destination(destination, false);
\par 
\par     // initialise yaw
\par     // To-Do: reset the yaw only when the previous navigation command is not a WP.  this would allow removing the special check for ROI
\par     if (auto_yaw.mode() != AUTO_YAW_ROI) \{
\par         auto_yaw.set_mode_to_default(false);
\par     \}
\par \}
\par 
\par // auto_wp_start - initialises waypoint controller to implement flying to a particular destination
\par void Copter::ModeAuto::wp_start(const Location_Class& dest_loc)
\par \{
\par     _mode = Auto_WP;
\par 
\par     // send target to waypoint controller
\par     if (!wp_nav->set_wp_destination(dest_loc)) \{
\par         // failure to set destination can only be because of missing terrain data
\par         copter.failsafe_terrain_on_event();
\par         return;
\par     \}
\par 
\par     // initialise yaw
\par     // To-Do: reset the yaw only when the previous navigation command is not a WP.  this would allow removing the special check for ROI
\par     if (auto_yaw.mode() != AUTO_YAW_ROI) \{
\par         auto_yaw.set_mode_to_default(false);
\par     \}
\par \}
\par 
\par // auto_land_start - initialises controller to implement a landing
\par void Copter::ModeAuto::land_start()
\par \{
\par     // set target to stopping point
\par     Vector3f stopping_point;
\par     loiter_nav->get_stopping_point_xy(stopping_point);
\par 
\par     // call location specific land start function
\par     land_start(stopping_point);
\par \}
\par 
\par // auto_land_start - initialises controller to implement a landing
\par void Copter::ModeAuto::land_start(const Vector3f& destination)
\par \{
\par     _mode = Auto_Land;
\par 
\par     // initialise loiter target destination
\par     loiter_nav->init_target(destination);
\par 
\par     // initialise position and desired velocity
\par     if (!pos_control->is_active_z()) \{
\par         pos_control->set_alt_target(inertial_nav.get_altitude());
\par         pos_control->set_desired_velocity_z(inertial_nav.get_velocity_z());
\par     \}
\par 
\par     // initialise yaw
\par     auto_yaw.set_mode(AUTO_YAW_HOLD);
\par \}
\par 
\par // auto_circle_movetoedge_start - initialise waypoint controller to move to edge of a circle with it's center at the specified location
\par //  we assume the caller has performed all required GPS_ok checks
\par void Copter::ModeAuto::circle_movetoedge_start(const Location_Class &circle_center, float radius_m)
\par \{
\par     // convert location to vector from ekf origin
\par     Vector3f circle_center_neu;
\par     if (!circle_center.get_vector_from_origin_NEU(circle_center_neu)) \{
\par         // default to current position and log error
\par         circle_center_neu = inertial_nav.get_position();
\par         copter.Log_Write_Error(ERROR_SUBSYSTEM_NAVIGATION, ERROR_CODE_FAILED_CIRCLE_INIT);
\par     \}
\par     copter.circle_nav->set_center(circle_center_neu);
\par 
\par     // set circle radius
\par     if (!is_zero(radius_m)) \{
\par         copter.circle_nav->set_radius(radius_m * 100.0f);
\par     \}
\par 
\par     // check our distance from edge of circle
\par     Vector3f circle_edge_neu;
\par     copter.circle_nav->get_closest_point_on_circle(circle_edge_neu);
\par     float dist_to_edge = (inertial_nav.get_position() - circle_edge_neu).length();
\par 
\par     // if more than 3m then fly to edge
\par     if (dist_to_edge > 300.0f) \{
\par         // set the state to move to the edge of the circle
\par         _mode = Auto_CircleMoveToEdge;
\par 
\par         // convert circle_edge_neu to Location_Class
\par         Location_Class circle_edge(circle_edge_neu);
\par 
\par         // convert altitude to same as command
\par         circle_edge.set_alt_cm(circle_center.alt, circle_center.get_alt_frame());
\par 
\par         // initialise wpnav to move to edge of circle
\par         if (!wp_nav->set_wp_destination(circle_edge)) \{
\par             // failure to set destination can only be because of missing terrain data
\par             copter.failsafe_terrain_on_event();
\par         \}
\par 
\par         // if we are outside the circle, point at the edge, otherwise hold yaw
\par         const Vector3f &curr_pos = inertial_nav.get_position();
\par         float dist_to_center = norm(circle_center_neu.x - curr_pos.x, circle_center_neu.y - curr_pos.y);
\par         if (dist_to_center > copter.circle_nav->get_radius() && dist_to_center > 500) \{
\par             auto_yaw.set_mode_to_default(false);
\par         \} else \{
\par             // vehicle is within circle so hold yaw to avoid spinning as we move to edge of circle
\par             auto_yaw.set_mode(AUTO_YAW_HOLD);
\par         \}
\par     \} else \{
\par         circle_start();
\par     \}
\par \}
\par 
\par // auto_circle_start - initialises controller to fly a circle in AUTO flight mode
\par //   assumes that circle_nav object has already been initialised with circle center and radius
\par void Copter::ModeAuto::circle_start()
\par \{
\par     _mode = Auto_Circle;
\par 
\par     // initialise circle controller
\par     copter.circle_nav->init(copter.circle_nav->get_center());
\par \}
\par 
\par // auto_spline_start - initialises waypoint controller to implement flying to a particular destination using the spline controller
\par //  seg_end_type can be SEGMENT_END_STOP, SEGMENT_END_STRAIGHT or SEGMENT_END_SPLINE.  If Straight or Spline the next_destination should be provided
\par void Copter::ModeAuto::spline_start(const Location_Class& destination, bool stopped_at_start,
\par                                AC_WPNav::spline_segment_end_type seg_end_type, 
\par                                const Location_Class& next_destination)
\par \{
\par     _mode = Auto_Spline;
\par 
\par     // initialise wpnav
\par     if (!wp_nav->set_spline_destination(destination, stopped_at_start, seg_end_type, next_destination)) \{
\par         // failure to set destination can only be because of missing terrain data
\par         copter.failsafe_terrain_on_event();
\par         return;
\par     \}
\par 
\par     // initialise yaw
\par     // To-Do: reset the yaw only when the previous navigation command is not a WP.  this would allow removing the special check for ROI
\par     if (auto_yaw.mode() != AUTO_YAW_ROI) \{
\par         auto_yaw.set_mode_to_default(false);
\par     \}
\par \}
\par 
\par #if NAV_GUIDED == ENABLED
\par // auto_nav_guided_start - hand over control to external navigation controller in AUTO mode
\par void Copter::ModeAuto::nav_guided_start()
\par \{
\par     _mode = Auto_NavGuided;
\par 
\par     // call regular guided flight mode initialisation
\par     copter.mode_guided.init(true);
\par 
\par     // initialise guided start time and position as reference for limit checking
\par     copter.mode_guided.limit_init_time_and_pos();
\par \}
\par #endif //NAV_GUIDED
\par 
\par bool Copter::ModeAuto::landing_gear_should_be_deployed() const
\par \{
\par     switch(_mode) \{
\par     case Auto_Land:
\par         return true;
\par     case Auto_RTL:
\par         return copter.mode_rtl.landing_gear_should_be_deployed();
\par     default:
\par         return false;
\par     \}
\par     return false;
\par \}
\par 
\par // auto_payload_place_start - initialises controller to implement a placing
\par void Copter::ModeAuto::payload_place_start()
\par \{
\par     // set target to stopping point
\par     Vector3f stopping_point;
\par     loiter_nav->get_stopping_point_xy(stopping_point);
\par 
\par     // call location specific place start function
\par     payload_place_start(stopping_point);
\par 
\par \}
\par 
\par // start_command - this function will be called when the ap_mission lib wishes to start a new command
\par bool Copter::ModeAuto::start_command(const AP_Mission::Mission_Command& cmd)
\par \{
\par     // To-Do: logging when new commands start/end
\par     if (copter.should_log(MASK_LOG_CMD)) \{
\par         copter.DataFlash.Log_Write_Mission_Cmd(copter.mission, cmd);
\par     \}
\par 
\par     switch(cmd.id) \{
\par 
\par     ///
\par     /// navigation commands
\par     ///
\par     case MAV_CMD_NAV_TAKEOFF:                   // 22
\par         do_takeoff(cmd);
\par         break;
\par 
\par     case MAV_CMD_NAV_WAYPOINT:                  // 16  Navigate to Waypoint
\par         do_nav_wp(cmd);
\par         break;
\par 
\par     case MAV_CMD_NAV_LAND:              // 21 LAND to Waypoint
\par         do_land(cmd);
\par         break;
\par 
\par     case MAV_CMD_NAV_PAYLOAD_PLACE:              // 94 place at Waypoint
\par         do_payload_place(cmd);
\par         break;
\par 
\par     case MAV_CMD_NAV_LOITER_UNLIM:              // 17 Loiter indefinitely
\par         do_loiter_unlimited(cmd);
\par         break;
\par 
\par     case MAV_CMD_NAV_LOITER_TURNS:              //18 Loiter N Times
\par         do_circle(cmd);
\par         break;
\par 
\par     case MAV_CMD_NAV_LOITER_TIME:              // 19
\par         do_loiter_time(cmd);
\par         break;
\par 
\par     case MAV_CMD_NAV_RETURN_TO_LAUNCH:             //20
\par         do_RTL();
\par         break;
\par 
\par     case MAV_CMD_NAV_SPLINE_WAYPOINT:           // 82  Navigate to Waypoint using spline
\par         do_spline_wp(cmd);
\par         break;
\par 
\par #if NAV_GUIDED == ENABLED
\par     case MAV_CMD_NAV_GUIDED_ENABLE:             // 92  accept navigation commands from external nav computer
\par         do_nav_guided_enable(cmd);
\par         break;
\par #endif
\par 
\par     case MAV_CMD_NAV_DELAY:                    // 94 Delay the next navigation command
\par         do_nav_delay(cmd);
\par         break;
\par 
\par     //
\par     // conditional commands
\par     //
\par     case MAV_CMD_CONDITION_DELAY:             // 112
\par         do_wait_delay(cmd);
\par         break;
\par 
\par     case MAV_CMD_CONDITION_DISTANCE:             // 114
\par         do_within_distance(cmd);
\par         break;
\par 
\par     case MAV_CMD_CONDITION_YAW:             // 115
\par         do_yaw(cmd);
\par         break;
\par 
\par     ///
\par     /// do commands
\par     ///
\par     case MAV_CMD_DO_CHANGE_SPEED:             // 178
\par         do_change_speed(cmd);
\par         break;
\par 
\par     case MAV_CMD_DO_SET_HOME:             // 179
\par         do_set_home(cmd);
\par         break;
\par 
\par     case MAV_CMD_DO_SET_SERVO:
\par         copter.ServoRelayEvents.do_set_servo(cmd.content.servo.channel, cmd.content.servo.pwm);
\par         break;
\par         
\par     case MAV_CMD_DO_SET_RELAY:
\par         copter.ServoRelayEvents.do_set_relay(cmd.content.relay.num, cmd.content.relay.state);
\par         break;
\par         
\par     case MAV_CMD_DO_REPEAT_SERVO:
\par         copter.ServoRelayEvents.do_repeat_servo(cmd.content.repeat_servo.channel, cmd.content.repeat_servo.pwm,
\par                                          cmd.content.repeat_servo.repeat_count, cmd.content.repeat_servo.cycle_time * 1000.0f);
\par         break;
\par         
\par     case MAV_CMD_DO_REPEAT_RELAY:
\par         copter.ServoRelayEvents.do_repeat_relay(cmd.content.repeat_relay.num, cmd.content.repeat_relay.repeat_count,
\par                                          cmd.content.repeat_relay.cycle_time * 1000.0f);
\par         break;
\par 
\par     case MAV_CMD_DO_SET_ROI:                // 201
\par         // point the copter and camera at a region of interest (ROI)
\par         do_roi(cmd);
\par         break;
\par 
\par     case MAV_CMD_DO_MOUNT_CONTROL:          // 205
\par         // point the camera to a specified angle
\par         do_mount_control(cmd);
\par         break;
\par     
\par     case MAV_CMD_DO_FENCE_ENABLE:
\par #if AC_FENCE == ENABLED
\par         if (cmd.p1 == 0) \{ //disable
\par             copter.fence.enable(false);
\par             gcs().send_text(MAV_SEVERITY_INFO, "Fence Disabled");
\par         \} else \{ //enable fence
\par             copter.fence.enable(true);
\par             gcs().send_text(MAV_SEVERITY_INFO, "Fence Enabled");
\par         \}
\par #endif //AC_FENCE == ENABLED
\par         break;
\par 
\par #if CAMERA == ENABLED
\par     case MAV_CMD_DO_CONTROL_VIDEO:                      // Control on-board camera capturing. |Camera ID (-1 for all)| Transmission: 0: disabled, 1: enabled compressed, 2: enabled raw| Transmissio
n mode: 0: video stream, >0: single images every n seconds (decimal)| Recording: 0: disabled, 1: enabled compressed, 2: enabled raw| Empty| Empty| Empty|
\par         break;
\par 
\par     case MAV_CMD_DO_DIGICAM_CONFIGURE:                  // Mission command to configur
e an on-board camera controller system. |Modes: P, TV, AV, M, Etc| Shutter speed: Divisor number for one second| Aperture: F stop number| ISO number e.g. 80, 100, 200, Etc| Exposure type enumerator| Command Identity| Main engine cut-off time before camera
 trigger in seconds/10 (0 means no cut-off)|
\par         do_digicam_configure(cmd);
\par         break;
\par 
\par     case MAV_CMD_DO_DIGICAM_CONTROL:                    // Mission command to control an on-board camera controller system. |Session control e.g. show/hide lens| Zoom's absolute position| Zooming step value to offset zoom from the current position| Focus 
Locking, Unlocking or Re-locking| Shooting Command| Command Identity| Empty|
\par         do_digicam_control(cmd);
\par         break;
\par 
\par     case MAV_CMD_DO_SET_CAM_TRIGG_DIST:
\par         copter.camera.set_trigger_distance(cmd.content.cam_trigg_dist.meters);
\par         break;
\par #endif
\par 
\par #if PARACHUTE == ENABLED
\par     case MAV_CMD_DO_PARACHUTE:                          // Mission command to configure or release parachute
\par         do_parachute(cmd);
\par         break;
\par #endif
\par 
\par #if GRIPPER_ENABLED == ENABLED
\par     case MAV_CMD_DO_GRIPPER:                            // Mission command to control gripper
\par         do_gripper(cmd);
\par         break;
\par #endif
\par 
\par #if NAV_GUIDED == ENABLED
\par     case MAV_CMD_DO_GUIDED_LIMITS:                      // 220  accept guided mode limits
\par         do_guided_limits(cmd);
\par         break;
\par #endif
\par 
\par #if WINCH_ENABLED == ENABLED
\par     case MAV_CMD_DO_WINCH:                             // Mission command to control winch
\par         do_winch(cmd);
\par         break;
\par #endif
\par 
\par     default:
\par         // do nothing with unrecognized MAVLink messages
\par         break;
\par     \}
\par 
\par     // always return success
\par     return true;
\par \}
\par 
\par // verify_command_callback - callback function called from ap-mission at 10hz or higher when a command is being run
\par //      we double check that the flight mode is AUTO to avoid the possibility of ap-mission triggering actions while we're not in AUTO mode
\par bool Copter::ModeAuto::verify_command_callback(const AP_Mission::Mission_Command& cmd)
\par \{
\par     if (copter.flightmode == &copter.mode_auto) \{
\par         bool cmd_complete = verify_command(cmd);
\par 
\par         // send message to GCS
\par         if (cmd_complete) \{
\par             gcs().send_mission_item_reached_message(cmd.index);
\par         \}
\par 
\par         return cmd_complete;
\par     \}
\par     return false;
\par \}
\par 
\par // exit_mission - function that is called once the mission completes
\par void Copter::ModeAuto::exit_mission()
\par \{
\par     // play a tone
\par     AP_Notify::events.mission_complete = 1;
\par     // if we are not on the ground switch to loiter or land
\par     if(!ap.land_complete) \{
\par         // try to enter loiter but if that fails land
\par         if(!loiter_start()) \{
\par             set_mode(LAND, MODE_REASON_MISSION_END);
\par         \}
\par     \}else\{
\par         // if we've landed it's safe to disarm
\par         copter.init_disarm_motors();
\par     \}
\par \}
\par 
\par // do_guided - start guided mode
\par bool Copter::ModeAuto::do_guided(const AP_Mission::Mission_Command& cmd)
\par \{
\par     // only process guided waypoint if we are in guided mode
\par     if (copter.control_mode != GUIDED && !(copter.control_mode == AUTO && mode() == Auto_NavGuided)) \{
\par         return false;
\par     \}
\par 
\par     // switch to handle different commands
\par     switch (cmd.id) \{
\par 
\par         case MAV_CMD_NAV_WAYPOINT:
\par         \{
\par             // set wp_nav's destination
\par             Location_Class dest(cmd.content.location);
\par             return copter.mode_guided.set_destination(dest);
\par         \}
\par 
\par         case MAV_CMD_CONDITION_YAW:
\par             do_yaw(cmd);
\par             return true;
\par 
\par         default:
\par             // reject unrecognised command
\par             return false;
\par     \}
\par 
\par     return true;
\par \}
\par 
\par uint32_t Copter::ModeAuto::wp_distance() const
\par \{
\par     return wp_nav->get_wp_distance_to_destination();
\par \}
\par 
\par int32_t Copter::ModeAuto::wp_bearing() const
\par \{
\par     return wp_nav->get_wp_bearing_to_destination();
\par \}
\par 
\par // update mission
\par void Copter::ModeAuto::run_autopilot()
\par \{
\par     copter.mission.update();
\par \}
\par 
\par /*******************************************************************************
\par Verify command Handlers
\par 
\par Each type of mission element has a "verify" operation. The verify
\par operation returns true when the mission element has completed and we
\par should move onto the next mission element.
\par Return true if we do not recognize the command so that we move on to the next command
\par *******************************************************************************/
\par 
\par bool Copter::ModeAuto::verify_command(const AP_Mission::Mission_Command& cmd)
\par \{
\par     switch(cmd.id) \{
\par     //
\par     // navigation commands
\par     //
\par     case MAV_CMD_NAV_TAKEOFF:
\par         return verify_takeoff();
\par 
\par     case MAV_CMD_NAV_WAYPOINT:
\par         return verify_nav_wp(cmd);
\par 
\par     case MAV_CMD_NAV_LAND:
\par         return verify_land();
\par 
\par     case MAV_CMD_NAV_PAYLOAD_PLACE:
\par         return verify_payload_place();
\par 
\par     case MAV_CMD_NAV_LOITER_UNLIM:
\par         return verify_loiter_unlimited();
\par 
\par     case MAV_CMD_NAV_LOITER_TURNS:
\par         return verify_circle(cmd);
\par 
\par     case MAV_CMD_NAV_LOITER_TIME:
\par         return verify_loiter_time();
\par 
\par     case MAV_CMD_NAV_RETURN_TO_LAUNCH:
\par         return verify_RTL();
\par 
\par     case MAV_CMD_NAV_SPLINE_WAYPOINT:
\par         return verify_spline_wp(cmd);
\par 
\par #if NAV_GUIDED == ENABLED
\par     case MAV_CMD_NAV_GUIDED_ENABLE:
\par         return verify_nav_guided_enable(cmd);
\par #endif
\par 
\par      case MAV_CMD_NAV_DELAY:
\par         return verify_nav_delay(cmd);
\par 
\par     ///
\par     /// conditional commands
\par     ///
\par     case MAV_CMD_CONDITION_DELAY:
\par         return verify_wait_delay();
\par 
\par     case MAV_CMD_CONDITION_DISTANCE:
\par         return verify_within_distance();
\par 
\par     case MAV_CMD_CONDITION_YAW:
\par         return verify_yaw();
\par 
\par     // do commands (always return true)
\par     case MAV_CMD_DO_CHANGE_SPEED:
\par     case MAV_CMD_DO_SET_HOME:
\par     case MAV_CMD_DO_SET_SERVO:
\par     case MAV_CMD_DO_SET_RELAY:
\par     case MAV_CMD_DO_REPEAT_SERVO:
\par     case MAV_CMD_DO_REPEAT_RELAY:
\par     case MAV_CMD_DO_SET_ROI:
\par     case MAV_CMD_DO_MOUNT_CONTROL:
\par     case MAV_CMD_DO_CONTROL_VIDEO:
\par     case MAV_CMD_DO_DIGICAM_CONFIGURE:
\par     case MAV_CMD_DO_DIGICAM_CONTROL:
\par     case MAV_CMD_DO_SET_CAM_TRIGG_DIST:
\par     case MAV_CMD_DO_PARACHUTE:  // assume parachute was released successfully
\par     case MAV_CMD_DO_GRIPPER:
\par     case MAV_CMD_DO_GUIDED_LIMITS:
\par     case MAV_CMD_DO_FENCE_ENABLE:
\par     case MAV_CMD_DO_WINCH:
\par         return true;
\par 
\par     default:
\par         // error message
\par         gcs().send_text(MAV_SEVERITY_WARNING,"Skipping invalid cmd #%i",cmd.id);
\par         // return true if we do not recognize the command so that we move on to the next command
\par         return true;
\par     \}
\par \}
\par 
\par // auto_takeoff_run - takeoff in auto mode
\par //      called by auto_run at 100hz or more
\par void Copter::ModeAuto::takeoff_run()
\par \{
\par     // if not auto armed or motor interlock not enabled set throttle to zero and exit immediately
\par     if (!motors->armed() || !ap.auto_armed || !motors->get_interlock()) \{
\par         // initialise wpnav targets
\par         wp_nav->shift_wp_origin_to_current_pos();
\par         zero_throttle_and_relax_ac();
\par         // clear i term when we're taking off
\par         set_throttle_takeoff();
\par         return;
\par     \}
\par 
\par     // process pilot's yaw input
\par     float target_yaw_rate = 0;
\par     if (!copter.failsafe.radio) \{
\par         // get pilot's desired yaw rate
\par         target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->get_control_in());
\par     \}
\par 
\par #if FRAME_CONFIG == HELI_FRAME
\par     // helicopters stay in landed state until rotor speed runup has finished
\par     if (motors->rotor_runup_complete()) \{
\par         set_land_complete(false);
\par     \} else \{
\par         // initialise wpnav targets
\par         wp_nav->shift_wp_origin_to_current_pos();
\par     \}
\par #else
\par     set_land_complete(false);
\par #endif
\par 
\par     // set motors to full range
\par     motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
\par 
\par     // run waypoint controller
\par     copter.failsafe_terrain_set_status(wp_nav->update_wpnav());
\par 
\par     // call z-axis position controller (wpnav should have already updated it's alt target)
\par     pos_control->update_z_controller();
\par 
\par     // call attitude controller
\par     copter.auto_takeoff_attitude_run(target_yaw_rate);
\par \}
\par 
\par // auto_wp_run - runs the auto waypoint controller
\par //      called by auto_run at 100hz or more
\par void Copter::ModeAuto::wp_run()
\par \{
\par     // if not auto armed or motor interlock not enabled set throttle to zero and exit immediately
\par     if (!motors->armed() || !ap.auto_armed || !motors->get_interlock()) \{
\par         // To-Do: reset waypoint origin to current location because copter is probably on the ground so we don't want it lurching left or right on take-off
\par         //    (of course it would be better if people just used take-off)
\par         zero_throttle_and_relax_ac();
\par         // clear i term when we're taking off
\par         set_throttle_takeoff();
\par         return;
\par     \}
\par    
\par     // process pilot's yaw input
\par     float target_yaw_rate = 0;
\par     if (!copter.failsafe.radio) \{
\par         // get pilot's desired yaw rate
\par         target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->get_control_in());
\par         if (!is_zero(target_yaw_rate)) \{
\par             auto_yaw.set_mode(AUTO_YAW_HOLD);
\par         \}
\par     \}
\par \tab 
\par \tab // set motors to full range
\par     motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
\par 
\par     // run waypoint controller 
\par     copter.failsafe_terrain_set_status(wp_nav->update_wpnav());
\par     
\par     }{\rtlch\fcs1 \af31507 \ltrch\fcs0 \lang1033\langfe1033\highlight7\langnp1033\insrsid15410912\charrsid15410912 // Auto Manual Altitude Control
\par     if (g2.auto_man_alt == 1) \{
\par         
\par         // get pilot desired climb rate alt control Alt_Hold
\par         float target_climb_rate = get_pilot_desired_climb_rate(channel_throttle->get_control_in());
\par         target_climb_rate = constrain_float(target_climb_rate, -get_pilot_speed_dn(), g.pilot_speed_up);
\par 
\par         // call attitude controller
\par         // attitude Alt_Hold
\par         pos_control->set_speed_z(-get_pilot_speed_dn(), g.pilot_speed_up);
\par         pos_control->set_accel_z(g.pilot_accel_z);
\par         pos_control->set_alt_target_to_current_alt();
\par         // change (inertial_nav.get_velocity_z ()) by (target_climb_rate) to add more control to the alt
\par         pos_control->set_desired_velocity_z(target_climb_rate);
\par         
\par         // adjust climb rate using rangefinder Alt_Hold
\par         if (copter.rangefinder_alt_ok()) \{
\par             // if rangefinder is ok, use surface tracking
\par             target_climb_rate = get_surface_tracking_climb_rate(target_climb_rate, pos_control->get_alt_target(), G_Dt);
\par         \}
\par 
\par         // update altitude target and call position controller Alt_Hold
\par         pos_control->set_alt_target_from_climb_rate_ff(target_climb_rate, G_Dt, false);
\par 
\par     \}}{\rtlch\fcs1 \af31507 \ltrch\fcs0 \lang1033\langfe1033\langnp1033\insrsid15410912\charrsid15410912 
\par     
\par     // call z-axis position controller (wpnav should have already updated it's alt target)
\par     pos_control->update_z_controller();
\par 
\par     // call attitude controller
\par     if (auto_yaw.mode() == AUTO_YAW_HOLD) \{
\par         // roll & pitch from waypoint controller, yaw rate from pilot
\par         attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(wp_nav->get_roll(), wp_nav->get_pitch(), target_yaw_rate);
\par     \}
\par     else \{
\par         // roll, pitch from waypoint controller, yaw heading from auto_heading()
\par         attitude_control->input_euler_angle_roll_pitch_yaw(wp_nav->get_roll(), wp_nav->get_pitch(), auto_yaw.yaw(), true);
\par     \}
\par \}
\par 
\par // auto_spline_run - runs the auto spline controller
\par //      called by auto_run at 100hz or more
\par void Copter::ModeAuto::spline_run()
\par \{
\par     // if not auto armed or motor interlock not enabled set throttle to zero and exit immediately
\par     if (!motors->armed() || !ap.auto_armed || !motors->get_interlock()) \{
\par         // To-Do: reset waypoint origin to current location because copter is probably on the ground so we don't want it lurching left or right on take-off
\par         //    (of course it would be better if people just used take-off)
\par         zero_throttle_and_relax_ac();
\par         // clear i term when we're taking off
\par         set_throttle_takeoff();
\par         return;
\par     \}
\par 
\par     // process pilot's yaw input
\par     float target_yaw_rate = 0;
\par     if (!copter.failsafe.radio) \{
\par         // get pilot's desired yaw rat
\par         target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->get_control_in());
\par         if (!is_zero(target_yaw_rate)) \{
\par \tab \tab \tab auto_yaw.set_mode(AUTO_YAW_HOLD);            
\par         \}
\par     \}
\par 
\par     // set motors to full range
\par     motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
\par 
\par     // run waypoint controller
\par     wp_nav->update_spline();
\par 
\par     // call z-axis position controller (wpnav should have already updated it's alt target)
\par     pos_control->update_z_controller();
\par 
\par     // call attitude controller
\par     if (auto_yaw.mode() == AUTO_YAW_HOLD) \{
\par \tab \tab // roll & pitch from waypoint controller, yaw rate from pilot
\par         attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(wp_nav->get_roll(), wp_nav->get_pitch(), target_yaw_rate);
\par     \} else \{
\par         // roll, pitch from waypoint controller, yaw heading from auto_heading()
\par         attitude_control->input_euler_angle_roll_pitch_yaw(wp_nav->get_roll(), wp_nav->get_pitch(), auto_yaw.yaw(), true);
\par     \}
\par \}
\par 
\par // auto_land_run - lands in auto mode
\par //      called by auto_run at 100hz or more
\par void Copter::ModeAuto::land_run()
\par \{
\par     // if not auto armed or landed or motor interlock not enabled set throttle to zero and exit immediately
\par     if (!motors->armed() || !ap.auto_armed || ap.land_complete || !motors->get_interlock()) \{
\par         zero_throttle_and_relax_ac();
\par         // set target to current position
\par         loiter_nav->init_target();
\par         return;
\par     \}
\par 
\par     // set motors to full range
\par     motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
\par     
\par     land_run_horizontal_control();
\par     land_run_vertical_control();
\par \}
\par 
\par // auto_rtl_run - rtl in AUTO flight mode
\par //      called by auto_run at 100hz or more
\par void Copter::ModeAuto::rtl_run()
\par \{
\par     // call regular rtl flight mode run function
\par     copter.mode_rtl.run(false);
\par \}
\par 
\par // auto_circle_run - circle in AUTO flight mode
\par //      called by auto_run at 100hz or more
\par void Copter::ModeAuto::circle_run()
\par \{
\par     // call circle controller
\par     copter.circle_nav->update();
\par 
\par     // call z-axis position controller
\par     pos_control->update_z_controller();
\par 
\par     // roll & pitch from waypoint controller, yaw rate from pilot
\par     attitude_control->input_euler_angle_roll_pitch_yaw(copter.circle_nav->get_roll(), copter.circle_nav->get_pitch(), copter.circle_nav->get_yaw(), true);
\par \}
\par 
\par #if NAV_GUIDED == ENABLED
\par // auto_nav_guided_run - allows control by external navigation controller
\par //      called by auto_run at 100hz or more
\par void Copter::ModeAuto::nav_guided_run()
\par \{
\par     // call regular guided flight mode run function
\par     copter.mode_guided.run();
\par \}
\par #endif  // NAV_GUIDED
\par 
\par // auto_loiter_run - loiter in AUTO flight mode
\par //      called by auto_run at 100hz or more
\par void Copter::ModeAuto::loiter_run()
\par \{
\par     // if not auto armed or motor interlock not enabled set throttle to zero and exit immediately
\par     if (!motors->armed() || !ap.auto_armed || ap.land_complete || !motors->get_interlock()) \{
\par         zero_throttle_and_relax_ac();
\par         return;
\par     \}
\par 
\par     // accept pilot input of yaw
\par     float target_yaw_rate = 0;
\par     if(!copter.failsafe.radio) \{
\par         target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->get_control_in());
\par     \}
\par 
\par     // set motors to full range
\par     motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
\par 
\par     // run waypoint and z-axis position controller
\par     copter.failsafe_terrain_set_status(wp_nav->update_wpnav());
\par 
\par     pos_control->update_z_controller();
\par     attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(wp_nav->get_roll(), wp_nav->get_pitch(), target_yaw_rate);
\par \}
\par 
\par // auto_payload_place_start - initialises controller to implement placement of a load
\par void Copter::ModeAuto::payload_place_start(const Vector3f& destination)
\par \{
\par     _mode = Auto_NavPayloadPlace;
\par     nav_payload_place.state = PayloadPlaceStateType_Calibrating_Hover_Start;
\par 
\par     // initialise loiter target destination
\par     loiter_nav->init_target(destination);
\par 
\par     // initialise position and desired velocity
\par     if (!pos_control->is_active_z()) \{
\par         pos_control->set_alt_target(inertial_nav.get_altitude());
\par         pos_control->set_desired_velocity_z(inertial_nav.get_velocity_z());
\par     \}
\par 
\par     // initialise yaw
\par     auto_yaw.set_mode(AUTO_YAW_HOLD);
\par \}
\par 
\par // auto_payload_place_run - places an object in auto mode
\par //      called by auto_run at 100hz or more
\par void Copter::ModeAuto::payload_place_run()
\par \{
\par     if (!payload_place_run_should_run()) \{
\par         zero_throttle_and_relax_ac();
\par         // set target to current position
\par         loiter_nav->init_target();
\par         return;
\par     \}
\par 
\par     // set motors to full range
\par     motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
\par 
\par     switch (nav_payload_place.state) \{
\par     case PayloadPlaceStateType_FlyToLocation:
\par     case PayloadPlaceStateType_Calibrating_Hover_Start:
\par     case PayloadPlaceStateType_Calibrating_Hover:
\par         return payload_place_run_loiter();
\par     case PayloadPlaceStateType_Descending_Start:
\par     case PayloadPlaceStateType_Descending:
\par         return payload_place_run_descend();
\par     case PayloadPlaceStateType_Releasing_Start:
\par     case PayloadPlaceStateType_Releasing:
\par     case PayloadPlaceStateType_Released:
\par     case PayloadPlaceStateType_Ascending_Start:
\par     case PayloadPlaceStateType_Ascending:
\par     case PayloadPlaceStateType_Done:
\par         return payload_place_run_loiter();
\par     \}
\par \}
\par 
\par bool Copter::ModeAuto::payload_place_run_should_run()
\par \{
\par     // muts be armed
\par     if (!motors->armed()) \{
\par         return false;
\par     \}
\par     // muts be auto-armed
\par     if (!ap.auto_armed) \{
\par         return false;
\par     \}
\par     // must not be landed
\par     if (ap.land_complete) \{
\par         return false;
\par     \}
\par     // interlock must be enabled (i.e. unsafe)
\par     if (!motors->get_interlock()) \{
\par         return false;
\par     \}
\par 
\par     return true;
\par \}
\par 
\par void Copter::ModeAuto::payload_place_run_loiter()
\par \{
\par     // loiter...
\par     land_run_horizontal_control();
\par 
\par     // run loiter controller
\par     loiter_nav->update(ekfGndSpdLimit, ekfNavVelGainScaler);
\par 
\par     // call attitude controller
\par     const float target_yaw_rate = 0;
\par     attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(wp_nav->get_roll(), wp_nav->get_pitch(), target_yaw_rate);
\par 
\par     // call position controller
\par     pos_control->update_z_controller();
\par \}
\par 
\par void Copter::ModeAuto::payload_place_run_descend()
\par \{
\par     land_run_horizontal_control();
\par     land_run_vertical_control();
\par \}
\par 
\par // terrain_adjusted_location: returns a Location with lat/lon from cmd
\par // and altitude from our current altitude adjusted for location
\par Location_Class Copter::ModeAuto::terrain_adjusted_location(const AP_Mission::Mission_Command& cmd) const
\par \{
\par     // convert to location class
\par     Location_Class target_loc(cmd.content.location);
\par     const Location_Class &current_loc = copter.current_loc;
\par 
\par     // decide if we will use terrain following
\par     int32_t curr_terr_alt_cm, target_terr_alt_cm;
\par     if (current_loc.get_alt_cm(Location_Class::ALT_FRAME_ABOVE_TERRAIN, curr_terr_alt_cm) &&
\par         target_loc.get_alt_cm(Location_Class::ALT_FRAME_ABOVE_TERRAIN, target_terr_alt_cm)) \{
\par         curr_terr_alt_cm = MAX(curr_terr_alt_cm,200);
\par         // if using terrain, set target altitude to current altitude above terrain
\par         target_loc.set_alt_cm(curr_terr_alt_cm, Location_Class::ALT_FRAME_ABOVE_TERRAIN);
\par     \} else \{
\par         // set target altitude to current altitude above home
\par         target_loc.set_alt_cm(current_loc.alt, Location_Class::ALT_FRAME_ABOVE_HOME);
\par     \}
\par     return target_loc;
\par \}
\par 
\par /********************************************************************************/
\par //\tab Nav (Must) commands
\par /********************************************************************************/
\par 
\par // do_takeoff - initiate takeoff navigation command
\par void Copter::ModeAuto::do_takeoff(const AP_Mission::Mission_Command& cmd)
\par \{
\par     // Set wp navigation target to safe altitude above current position
\par     takeoff_start(cmd.content.location);
\par \}
\par 
\par // do_nav_wp - initiate move to next waypoint
\par void Copter::ModeAuto::do_nav_wp(const AP_Mission::Mission_Command& cmd)
\par \{
\par     Location_Class target_loc(cmd.content.location);
\par     const Location_Class &current_loc = copter.current_loc;
\par 
\par     // use current lat, lon if zero
\par     if (target_loc.lat == 0 && target_loc.lng == 0) \{
\par         target_loc.lat = current_loc.lat;
\par         target_loc.lng = current_loc.lng;
\par     \}
\par     // use current altitude if not provided
\par     if (target_loc.alt == 0) \{
\par         // set to current altitude but in command's alt frame
\par         int32_t curr_alt;
\par         if (current_loc.get_alt_cm(target_loc.get_alt_frame(),curr_alt)) \{
\par             target_loc.set_alt_cm(curr_alt, target_loc.get_alt_frame());
\par         \} else \{
\par             // default to current altitude as alt-above-home
\par             target_loc.set_alt_cm(current_loc.alt, current_loc.get_alt_frame());
\par         \}
\par \tab \}
\par \tab 
\par \tab // this will be used to remember the time in millis after we reach or pass the WP.
\par     loiter_time = 0;
\par     // this is the delay, stored in seconds
\par     loiter_time_max = cmd.p1;
\par     
\par     // Set wp navigation target
\par \tab 
\par \tab // Set wp navigation target
\par 
\par     wp_start(target_loc);
\par \tab 
\par \tab // if no delay as well as not final waypoint set the waypoint as "fast"
\par     AP_Mission::Mission_Command temp_cmd;
\par     if (loiter_time_max == 0 && copter.mission.get_next_nav_cmd(cmd.index+1, temp_cmd)) \{
\par         copter.wp_nav->set_fast_waypoint(true);
\par     \}
\par \}
\par 
\par // do_land - initiate landing procedure
\par void Copter::ModeAuto::do_land(const AP_Mission::Mission_Command& cmd)
\par \{
\par     // To-Do: check if we have already landed
\par 
\par     // if location provided we fly to that location at current altitude
\par     if (cmd.content.location.lat != 0 || cmd.content.location.lng != 0) \{
\par         // set state to fly to location
\par         land_state = LandStateType_FlyToLocation;
\par 
\par         Location_Class target_loc = terrain_adjusted_location(cmd);
\par 
\par         wp_start(target_loc);
\par     \}else\{
\par         // set landing state
\par         land_state = LandStateType_Descending;
\par 
\par         // initialise landing controller
\par         land_start();
\par     \}
\par \}
\par 
\par // do_loiter_unlimited - start loitering with no end conditions
\par // note: caller should set yaw_mode
\par void Copter::ModeAuto::do_loiter_unlimited(const AP_Mission::Mission_Command& cmd)
\par \{
\par     // convert back to location
\par     Location_Class target_loc(cmd.content.location);
\par     const Location_Class &current_loc = copter.current_loc;
\par 
\par     // use current location if not provided
\par     if (target_loc.lat == 0 && target_loc.lng == 0) \{
\par         // To-Do: make this simpler
\par         Vector3f temp_pos;
\par         copter.wp_nav->get_wp_stopping_point_xy(temp_pos);
\par         Location_Class temp_loc(temp_pos);
\par         target_loc.lat = temp_loc.lat;
\par         target_loc.lng = temp_loc.lng;
\par     \}
\par 
\par     // use current altitude if not provided
\par     // To-Do: use z-axis stopping point instead of current alt
\par     if (target_loc.alt == 0) \{
\par         // set to current altitude but in command's alt frame
\par         int32_t curr_alt;
\par         if (current_loc.get_alt_cm(target_loc.get_alt_frame(),curr_alt)) \{
\par             target_loc.set_alt_cm(curr_alt, target_loc.get_alt_frame());
\par         \} else \{
\par             // default to current altitude as alt-above-home
\par             target_loc.set_alt_cm(current_loc.alt, current_loc.get_alt_frame());
\par         \}
\par     \}
\par 
\par     // start way point navigator and provide it the desired location
\par     wp_start(target_loc);
\par \}
\par 
\par // do_circle - initiate moving in a circle
\par void Copter::ModeAuto::do_circle(const AP_Mission::Mission_Command& cmd)
\par \{
\par     Location_Class circle_center(cmd.content.location);
\par     const Location_Class &current_loc = copter.current_loc;
\par 
\par     // default lat/lon to current position if not provided
\par     // To-Do: use stopping point or position_controller's target instead of current location to avoid jerk?
\par     if (circle_center.lat == 0 && circle_center.lng == 0) \{
\par         circle_center.lat = current_loc.lat;
\par         circle_center.lng = current_loc.lng;
\par     \}
\par 
\par     // default target altitude to current altitude if not provided
\par     if (circle_center.alt == 0) \{
\par         int32_t curr_alt;
\par         if (current_loc.get_alt_cm(circle_center.get_alt_frame(),curr_alt)) \{
\par             // circle altitude uses frame from command
\par             circle_center.set_alt_cm(curr_alt,circle_center.get_alt_frame());
\par         \} else \{
\par             // default to current altitude above origin
\par             circle_center.set_alt_cm(current_loc.alt, current_loc.get_alt_frame());
\par             copter.Log_Write_Error(ERROR_SUBSYSTEM_TERRAIN, ERROR_CODE_MISSING_TERRAIN_DATA);
\par         \}
\par     \}
\par 
\par     // calculate radius
\par     uint8_t circle_radius_m = HIGHBYTE(cmd.p1); // circle radius held in high byte of p1
\par 
\par     // move to edge of circle (verify_circle) will ensure we begin circling once we reach the edge
\par     circle_movetoedge_start(circle_center, circle_radius_m);
\par \}
\par 
\par // do_loiter_time - initiate loitering at a point for a given time period
\par // note: caller should set yaw_mode
\par void Copter::ModeAuto::do_loiter_time(const AP_Mission::Mission_Command& cmd)
\par \{
\par     // re-use loiter unlimited
\par     do_loiter_unlimited(cmd);
\par 
\par     // setup loiter timer
\par     loiter_time     = 0;
\par     loiter_time_max = cmd.p1;     // units are (seconds)
\par \}
\par 
\par // do_spline_wp - initiate move to next waypoint
\par void Copter::ModeAuto::do_spline_wp(const AP_Mission::Mission_Command& cmd)
\par \{
\par     Location_Class target_loc(cmd.content.location);
\par     const Location_Class &current_loc = copter.current_loc;
\par 
\par     // use current lat, lon if zero
\par     if (target_loc.lat == 0 && target_loc.lng == 0) \{
\par         target_loc.lat = current_loc.lat;
\par         target_loc.lng = current_loc.lng;
\par     \}
\par     // use current altitude if not provided
\par     if (target_loc.alt == 0) \{
\par         // set to current altitude but in command's alt frame
\par         int32_t curr_alt;
\par         if (current_loc.get_alt_cm(target_loc.get_alt_frame(),curr_alt)) \{
\par             target_loc.set_alt_cm(curr_alt, target_loc.get_alt_frame());
\par         \} else \{
\par             // default to current altitude as alt-above-home
\par             target_loc.set_alt_cm(current_loc.alt, current_loc.get_alt_frame());
\par         \}
\par     \}
\par 
\par     // this will be used to remember the time in millis after we reach or pass the WP.
\par     loiter_time = 0;
\par     // this is the delay, stored in seconds
\par     loiter_time_max = cmd.p1;
\par 
\par     // determine segment start and end type
\par     bool stopped_at_start = true;
\par     AC_WPNav::spline_segment_end_type seg_end_type = AC_WPNav::SEGMENT_END_STOP;
\par     AP_Mission::Mission_Command temp_cmd;
\par 
\par     // if previous command was a wp_nav command with no delay set stopped_at_start to false
\par     // To-Do: move processing of delay into wp-nav controller to allow it to determine the stopped_at_start value itself?
\par     uint16_t prev_cmd_idx = copter.mission.get_prev_nav_cmd_index();
\par     if (prev_cmd_idx != AP_MISSION_CMD_INDEX_NONE) \{
\par         if (copter.mission.read_cmd_from_storage(prev_cmd_idx, temp_cmd)) \{
\par             if ((temp_cmd.id == MAV_CMD_NAV_WAYPOINT || temp_cmd.id == MAV_CMD_NAV_SPLINE_WAYPOINT) && temp_cmd.p1 == 0) \{
\par                 stopped_at_start = false;
\par             \}
\par         \}
\par     \}
\par 
\par     // if there is no delay at the end of this segment get next nav command
\par     Location_Class next_loc;
\par     if (cmd.p1 == 0 && copter.mission.get_next_nav_cmd(cmd.index+1, temp_cmd)) \{
\par         next_loc = temp_cmd.content.location;
\par         // default lat, lon to first waypoint's lat, lon
\par         if (next_loc.lat == 0 && next_loc.lng == 0) \{
\par             next_loc.lat = target_loc.lat;
\par             next_loc.lng = target_loc.lng;
\par         \}
\par         // default alt to first waypoint's alt but in next waypoint's alt frame
\par         if (next_loc.alt == 0) \{
\par             int32_t next_alt;
\par             if (target_loc.get_alt_cm(next_loc.get_alt_frame(), next_alt)) \{
\par                 next_loc.set_alt_cm(next_alt, next_loc.get_alt_frame());
\par             \} else \{
\par                 // default to first waypoints altitude
\par                 next_loc.set_alt_cm(target_loc.alt, target_loc.get_alt_frame());
\par             \}
\par         \}
\par         // if the next nav command is a waypoint set end type to spline or straight
\par         if (temp_cmd.id == MAV_CMD_NAV_WAYPOINT) \{
\par             seg_end_type = AC_WPNav::SEGMENT_END_STRAIGHT;
\par         \}else if (temp_cmd.id == MAV_CMD_NAV_SPLINE_WAYPOINT) \{
\par             seg_end_type = AC_WPNav::SEGMENT_END_SPLINE;
\par         \}
\par     \}
\par 
\par     // set spline navigation target
\par     spline_start(target_loc, stopped_at_start, seg_end_type, next_loc);
\par \}
\par 
\par #if NAV_GUIDED == ENABLED
\par // do_nav_guided_enable - initiate accepting commands from external nav computer
\par void Copter::ModeAuto::do_nav_guided_enable(const AP_Mission::Mission_Command& cmd)
\par \{
\par     if (cmd.p1 > 0) \{
\par         // initialise guided limits
\par         copter.mode_guided.limit_init_time_and_pos();
\par 
\par         // set spline navigation target
\par         nav_guided_start();
\par     \}
\par \}
\par 
\par // do_guided_limits - pass guided limits to guided controller
\par void Copter::ModeAuto::do_guided_limits(const AP_Mission::Mission_Command& cmd)
\par \{
\par     copter.mode_guided.limit_set(
\par         cmd.p1 * 1000, // convert seconds to ms
\par         cmd.content.guided_limits.alt_min * 100.0f,    // convert meters to cm
\par \tab \tab cmd.content.guided_limits.alt_max * 100.0f,    // convert meters to cm
\par \tab \tab cmd.content.guided_limits.horiz_max * 100.0f); // convert meters to cm
\par \}
\par #endif  // NAV_GUIDED
\par 
\par // do_nav_delay - Delay the next navigation command
\par void Copter::ModeAuto::do_nav_delay(const AP_Mission::Mission_Command& cmd)
\par \{
\par     nav_delay_time_start = millis();
\par 
\par     if (cmd.content.nav_delay.seconds > 0) \{
\par         // relative delay
\par         nav_delay_time_max = cmd.content.nav_delay.seconds * 1000; // convert seconds to milliseconds
\par     \} else \{
\par         // absolute delay to utc time
\par         nav_delay_time_max = hal.util->get_time_utc(cmd.content.nav_delay.hour_utc, cmd.content.nav_delay.min_utc, cmd.content.nav_delay.sec_utc, 0);
\par     \}
\par     gcs().send_text(MAV_SEVERITY_INFO, "Delaying %u sec",(unsigned int)(nav_delay_time_max/1000));
\par \}
\par 
\par /********************************************************************************/
\par //\tab Condition (May) commands
\par /********************************************************************************/
\par 
\par void Copter::ModeAuto::do_wait_delay(const AP_Mission::Mission_Command& cmd)
\par \{
\par     condition_start = millis();
\par     condition_value = cmd.content.delay.seconds * 1000;     // convert seconds to milliseconds
\par \}
\par 
\par void Copter::ModeAuto::do_within_distance(const AP_Mission::Mission_Command& cmd)
\par \{
\par     condition_value  = cmd.content.distance.meters * 100;
\par \}
\par 
\par void Copter::ModeAuto::do_yaw(const AP_Mission::Mission_Command& cmd)
\par \{
\par \tab auto_yaw.set_fixed_yaw(
\par \tab \tab cmd.content.yaw.angle_deg,
\par \tab \tab cmd.content.yaw.turn_rate_dps,
\par \tab \tab cmd.content.yaw.direction,
\par \tab \tab cmd.content.yaw.relative_angle > 0);
\par \}
\par 
\par /********************************************************************************/
\par //\tab Do (Now) commands
\par /********************************************************************************/
\par 
\par 
\par 
\par void Copter::ModeAuto::do_change_speed(const AP_Mission::Mission_Command& cmd)
\par \{
\par     if (cmd.content.speed.target_ms > 0) \{
\par         copter.wp_nav->set_speed_xy(cmd.content.speed.target_ms * 100.0f);
\par     \}
\par \}
\par 
\par void Copter::ModeAuto::do_set_home(const AP_Mission::Mission_Command& cmd)
\par \{
\par     if(cmd.p1 == 1 || (cmd.content.location.lat == 0 && cmd.content.location.lng == 0 && cmd.content.location.alt == 0)) \{
\par         copter.set_home_to_current_location(false);
\par     \} else \{
\par         copter.set_home(cmd.content.location, false);
\par     \}
\par \}
\par 
\par // do_roi - starts actions required by MAV_CMD_DO_SET_ROI
\par //          this involves either moving the camera to point at the ROI (region of interest)
\par //          and possibly rotating the copter to point at the ROI if our mount type does not support a yaw feature
\par //\tab TO-DO: add support for other features of MAV_CMD_DO_SET_ROI including pointing at a given waypoint
\par void Copter::ModeAuto::do_roi(const AP_Mission::Mission_Command& cmd)
\par \{
\par     auto_yaw.set_roi(cmd.content.location);
\par \}
\par 
\par // point the camera to a specified angle
\par void Copter::ModeAuto::do_mount_control(const AP_Mission::Mission_Command& cmd)
\par \{
\par #if MOUNT == ENABLED
\par     if(!copter.camera_mount.has_pan_control()) \{
\par         auto_yaw.set_fixed_yaw(cmd.content.mount_control.yaw,0.0f,0,0);
\par     \}
\par     copter.camera_mount.set_angle_targets(cmd.content.mount_control.roll, cmd.content.mount_control.pitch, cmd.content.mount_control.yaw);
\par #endif
\par \}
\par 
\par #if CAMERA == ENABLED
\par 
\par // do_digicam_configure Send Digicam Configure message with the camera library
\par void Copter::ModeAuto::do_digicam_configure(const AP_Mission::Mission_Command& cmd)
\par \{
\par     copter.camera.configure(
\par         cmd.content.digicam_configure.shooting_mode,
\par         cmd.content.digicam_configure.shutter_speed,
\par         cmd.content.digicam_configure.aperture,
\par         cmd.content.digicam_configure.ISO,
\par         cmd.content.digicam_configure.exposure_type,
\par         cmd.content.digicam_configure.cmd_id,
\par         cmd.content.digicam_configure.engine_cutoff_time);
\par \}
\par 
\par // do_digicam_control Send Digicam Control message with the camera library
\par void Copter::ModeAuto::do_digicam_control(const AP_Mission::Mission_Command& cmd)
\par \{
\par     copter.camera.control(cmd.content.digicam_control.session,
\par                            cmd.content.digicam_control.zoom_pos,
\par                            cmd.content.digicam_control.zoom_step,
\par                            cmd.content.digicam_control.focus_lock,
\par                            cmd.content.digicam_control.shooting_cmd,
\par                            }{\rtlch\fcs1 \af31507 \ltrch\fcs0 \insrsid15410912 cmd.content.digicam_control.cmd_id);
\par }{\rtlch\fcs1 \af31507 \ltrch\fcs0 \lang1033\langfe1033\langnp1033\insrsid15410912\charrsid15410912 \}
\par 
\par #endif
\par 
\par #if PARACHUTE == ENABLED
\par // do_parachute - configure or release parachute
\par void Copter::ModeAuto::do_parachute(const AP_Mission::Mission_Command& cmd)
\par \{
\par     switch (cmd.p1) \{
\par         case PARACHUTE_DISABLE:
\par             copter.parachute.enabled(false);
\par             Log_Write_Event(DATA_PARACHUTE_DISABLED);
\par             break;
\par         case PARACHUTE_ENABLE:
\par             copter.parachute.enabled(true);
\par             Log_Write_Event(DATA_PARACHUTE_ENABLED);
\par             break;
\par         case PARACHUTE_RELEASE:
\par             copter.parachute_release();
\par             break;
\par         default:
\par             // do nothing
\par             break;
\par     \}
\par \}
\par #endif
\par 
\par #if GRIPPER_ENABLED == ENABLED
\par // do_gripper - control gripper
\par void Copter::ModeAuto::do_gripper(const AP_Mission::Mission_Command& cmd)
\par \{
\par     // Note: we ignore the gripper num parameter because we only support one gripper
\par     switch (cmd.content.gripper.action) \{
\par         case GRIPPER_ACTION_RELEASE:
\par             g2.gripper.release();
\par             Log_Write_Event(DATA_GRIPPER_RELEASE);
\par             break;
\par         case GRIPPER_ACTION_GRAB:
\par             g2.gripper.grab();
\par             Log_Write_Event(DATA_GRIPPER_GRAB);
\par             break;
\par         default:
\par             // do nothing
\par             break;
\par     \}
\par \}
\par #endif
\par 
\par #if WINCH_ENABLED == ENABLED
\par // control winch based on mission command
\par void Copter::ModeAuto::do_winch(const AP_Mission::Mission_Command& cmd)
\par \{
\par     // Note: we ignore the gripper num parameter because we only support one gripper
\par     switch (cmd.content.winch.action) \{
\par         case WINCH_RELAXED:
\par             g2.winch.relax();
\par             Log_Write_Event(DATA_WINCH_RELAXED);
\par             break;
\par         case WINCH_RELATIVE_LENGTH_CONTROL:
\par             g2.winch.release_length(cmd.content.winch.release_length, cmd.content.winch.release_rate);
\par             Log_Write_Event(DATA_WINCH_LENGTH_CONTROL);
\par             break;
\par         case WINCH_RATE_CONTROL:
\par             g2.winch.set_desired_rate(cmd.content.winch.release_rate);
\par             Log_Write_Event(DATA_WINCH_RATE_CONTROL);
\par             break;
\par         default:
\par             // do nothing
\par             break;
\par     \}
\par \}
\par #endif
\par 
\par // do_payload_place - initiate placing procedure
\par void Copter::ModeAuto::do_payload_place(const AP_Mission::Mission_Command& cmd)
\par \{
\par     // if location provided we fly to that location at current altitude
\par     if (cmd.content.location.lat != 0 || cmd.content.location.lng != 0) \{
\par         // set state to fly to location
\par         nav_payload_place.state = PayloadPlaceStateType_FlyToLocation;
\par 
\par         Location_Class target_loc = terrain_adjusted_location(cmd);
\par 
\par         wp_start(target_loc);
\par     \} else \{
\par         nav_payload_place.state = PayloadPlaceStateType_Calibrating_Hover_Start;
\par 
\par         // initialise placing controller
\par         payload_place_start();
\par     \}
\par     nav_payload_place.descend_max = cmd.p1;
\par \}
\par 
\par // do_RTL - start Return-to-Launch
\par void Copter::ModeAuto::do_RTL(void)
\par \{
\par     // start rtl in auto flight mode
\par     rtl_start();
\par \}
\par 
\par /********************************************************************************/
\par //\tab Verify Nav (Must) commands
\par /********************************************************************************/
\par 
\par // verify_takeoff - check if we have completed the takeoff
\par bool Copter::ModeAuto::verify_takeoff()
\par \{
\par     // have we reached our target altitude?
\par     return copter.wp_nav->reached_wp_destination();
\par \}
\par 
\par // verify_land - returns true if landing has been completed
\par bool Copter::ModeAuto::verify_land()
\par \{
\par     bool retval = false;
\par 
\par     switch (land_state) \{
\par         case LandStateType_FlyToLocation:
\par             // check if we've reached the location
\par             if (copter.wp_nav->reached_wp_destination()) \{
\par                 // get destination so we can use it for loiter target
\par                 Vector3f dest = copter.wp_nav->get_wp_destination();
\par 
\par                 // initialise landing controller
\par                 land_start(dest);
\par 
\par                 // advance to next state
\par                 land_state = LandStateType_Descending;
\par             \}
\par             break;
\par 
\par         case LandStateType_Descending:
\par             // rely on THROTTLE_LAND mode to correctly update landing status
\par             retval = ap.land_complete;
\par             break;
\par 
\par         default:
\par             // this should never happen
\par             // TO-DO: log an error
\par             retval = true;
\par             break;
\par     \}
\par 
\par     // true is returned if we've successfully landed
\par     return retval;
\par \}
\par 
\par #define NAV_PAYLOAD_PLACE_DEBUGGING 0
\par 
\par #if NAV_PAYLOAD_PLACE_DEBUGGING
\par #include <stdio.h>
\par #define debug(fmt, args ...)  do \{::fprintf(stderr,"%s:%d: " fmt "\\n", __FUNCTION__, __LINE__, ## args); \} while(0)
\par #else
\par #define debug(fmt, args ...)
\par #endif
\par 
\par // verify_payload_place - returns true if placing has been completed
\par bool Copter::ModeAuto::verify_payload_place()
\par \{
\par     const uint16_t hover_throttle_calibrate_time = 2000; // milliseconds
\par     const uint16_t descend_throttle_calibrate_time = 2000; // milliseconds
\par     const float hover_throttle_placed_fraction = 0.7; // i.e. if throttle is less than 70% of hover we have placed
\par     const float descent_throttle_placed_fraction = 0.9; // i.e. if throttle is less than 90% of descent throttle we have placed
\par     const uint16_t placed_time = 500; // how long we have to be below a throttle threshold before considering placed
\par 
\par     const float current_throttle_level = motors->get_throttle();
\par     const uint32_t now =  AP_HAL::millis();
\par 
\par     // if we discover we've landed then immediately release the load:
\par     if (ap.land_complete) \{
\par         switch (nav_payload_place.state) \{
\par         case PayloadPlaceStateType_FlyToLocation:
\par         case PayloadPlaceStateType_Calibrating_Hover_Start:
\par         case PayloadPlaceStateType_Calibrating_Hover:
\par         case PayloadPlaceStateType_Descending_Start:
\par         case PayloadPlaceStateType_Descending:
\par             gcs().send_text(MAV_SEVERITY_INFO, "NAV_PLACE: landed");
\par             nav_payload_place.state = PayloadPlaceStateType_Releasing_Start;
\par             break;
\par         case PayloadPlaceStateType_Releasing_Start:
\par         case PayloadPlaceStateType_Releasing:
\par         case PayloadPlaceStateType_Released:
\par         case PayloadPlaceStateType_Ascending_Start:
\par         case PayloadPlaceStateType_Ascending:
\par         case PayloadPlaceStateType_Done:
\par             break;
\par         \}
\par     \}
\par 
\par     switch (nav_payload_place.state) \{
\par     case PayloadPlaceStateType_FlyToLocation:
\par         if (!copter.wp_nav->reached_wp_destination()) \{
\par             return false;
\par         \}
\par         // we're there; set loiter target
\par         nav_payload_place.state = PayloadPlaceStateType_Calibrating_Hover_Start;
\par         FALLTHROUGH;
\par     case PayloadPlaceStateType_Calibrating_Hover_Start:
\par         // hover for 1 second to get an idea of what our hover
\par         // throttle looks like
\par         debug("Calibrate start");
\par         nav_payload_place.hover_start_timestamp = now;
\par         nav_payload_place.state = PayloadPlaceStateType_Calibrating_Hover;
\par         FALLTHROUGH;
\par     case PayloadPlaceStateType_Calibrating_Hover: \{
\par         if (now - nav_payload_place.hover_start_timestamp < hover_throttle_calibrate_time) \{
\par             // still calibrating...
\par             debug("Calibrate Timer: %d", now - nav_payload_place.hover_start_timestamp);
\par             return false;
\par         \}
\par         // we have a valid calibration.  Hopefully.
\par         nav_payload_place.hover_throttle_level = current_throttle_level;
\par         const float hover_throttle_delta = fabsf(nav_payload_place.hover_throttle_level - motors->get_throttle_hover());
\par         gcs().send_text(MAV_SEVERITY_INFO, "hover throttle delta: %f", static_cast<double>(hover_throttle_delta));
\par         nav_payload_place.state = PayloadPlaceStateType_Descending_Start;
\par         \}
\par         FALLTHROUGH;
\par     case PayloadPlaceStateType_Descending_Start:
\par         nav_payload_place.descend_start_timestamp = now;
\par         nav_payload_place.descend_start_altitude = inertial_nav.get_altitude();
\par         nav_payload_place.descend_throttle_level = 0;
\par         nav_payload_place.state = PayloadPlaceStateType_Descending;
\par         FALLTHROUGH;
\par     case PayloadPlaceStateType_Descending:
\par         // make sure we don't descend too far:
\par         debug("descended: %f cm (%f cm max)", (nav_payload_place.descend_start_altitude - inertial_nav.get_altitude()), nav_payload_place.descend_max);
\par         if (!is_zero(nav_payload_place.descend_max) &&
\par             nav_payload_place.descend_start_altitude - inertial_nav.get_altitude()  > nav_payload_place.descend_max) \{
\par             nav_payload_place.state = PayloadPlaceStateType_Ascending;
\par             gcs().send_text(MAV_SEVERITY_WARNING, "Reached maximum descent");
\par             return false; // we'll do any cleanups required next time through the loop
\par         \}
\par         // see if we've been descending long enough to calibrate a descend-throttle-level:
\par         if (is_zero(nav_payload_place.descend_throttle_level) &&
\par             now - nav_payload_place.descend_start_timestamp > descend_throttle_calibrate_time) \{
\par             nav_payload_place.descend_throttle_level = current_throttle_level;
\par         \}
\par         // watch the throttle to determine whether the load has been placed
\par         // debug("hover ratio: %f   descend ratio: %f\\n", current_throttle_level/nav_payload_place.hover_throttle_level, ((nav_payload_place.descend_throttle_level == 0) ? -1.0f : current_throttle_level/nav_payload_place.descend_throttle_level));
\par         if (current_throttle_level/nav_payload_place.hover_throttle_level > hover_throttle_placed_fraction &&
\par             (is_zero(nav_payload_place.descend_throttle_level) ||
\par              current_throttle_level/nav_payload_place.descend_throttle_level > descent_throttle_placed_fraction)) \{
\par             // throttle is above both threshold ratios (or above hover threshold ration and descent threshold ratio not yet valid)
\par             nav_payload_place.place_start_timestamp = 0;
\par             return false;
\par         \}
\par         if (nav_payload_place.place_start_timestamp == 0) \{
\par             // we've only just now hit the correct throttle level
\par             nav_payload_place.place_start_timestamp = now;
\par             return false;
\par         \} else if (now - nav_payload_place.place_start_timestamp < placed_time) \{
\par             // keep going down....
\par             debug("Place Timer: %d", now - nav_payload_place.place_start_timestamp);
\par             return false;
\par         \}
\par         nav_payload_place.state = PayloadPlaceStateType_Releasing_Start;
\par         FALLTHROUGH;
\par     case PayloadPlaceStateType_Releasing_Start:
\par #if GRIPPER_ENABLED == ENABLED
\par         if (g2.gripper.valid()) \{
\par             gcs().send_text(MAV_SEVERITY_INFO, "Releasing the gripper");
\par             g2.gripper.release();
\par         \} else \{
\par             gcs().send_text(MAV_SEVERITY_INFO, "Gripper not valid");
\par             nav_payload_place.state = PayloadPlaceStateType_Ascending_Start;
\par             break;
\par         \}
\par #else
\par         gcs().send_text(MAV_SEVERITY_INFO, "Gripper code disabled");
\par #endif
\par         nav_payload_place.state = PayloadPlaceStateType_Releasing;
\par         FALLTHROUGH;
\par     case PayloadPlaceStateType_Releasing:
\par #if GRIPPER_ENABLED == ENABLED
\par         if (g2.gripper.valid() && !g2.gripper.released()) \{
\par             return false;
\par         \}
\par #endif
\par         nav_payload_place.state = PayloadPlaceStateType_Released;
\par         FALLTHROUGH;
\par     case PayloadPlaceStateType_Released: \{
\par         nav_payload_place.state = PayloadPlaceStateType_Ascending_Start;
\par         \}
\par         FALLTHROUGH;
\par     case PayloadPlaceStateType_Ascending_Start: \{
\par         Location_Class target_loc = inertial_nav.get_position();
\par         target_loc.alt = nav_payload_place.descend_start_altitude;
\par         wp_start(target_loc);
\par         nav_payload_place.state = PayloadPlaceStateType_Ascending;
\par         \}
\par         FALLTHROUGH;
\par     case PayloadPlaceStateType_Ascending:
\par         if (!copter.wp_nav->reached_wp_destination()) \{
\par             return false;
\par         \}
\par         nav_payload_place.state = PayloadPlaceStateType_Done;
\par         FALLTHROUGH;
\par     case PayloadPlaceStateType_Done:
\par         return true;
\par     default:
\par         // this should never happen
\par         // TO-DO: log an error
\par         return true;
\par     \}
\par     // should never get here
\par     return true;
\par \}
\par #undef debug
\par 
\par bool Copter::ModeAuto::verify_loiter_unlimited()
\par \{
\par     return false;
\par \}
\par 
\par // verify_loiter_time - check if we have loitered long enough
\par bool Copter::ModeAuto::verify_loiter_time()
\par \{
\par     // return immediately if we haven't reached our destination
\par     if (!copter.wp_nav->reached_wp_destination()) \{
\par         return false;
\par     \}
\par 
\par     // start our loiter timer
\par     if( loiter_time == 0 ) \{
\par         loiter_time = millis();
\par     \}
\par 
\par     // check if loiter timer has run out
\par     return (((millis() - loiter_time) / 1000) >= loiter_time_max);
\par \}
\par 
\par // verify_RTL - handles any state changes required to implement RTL
\par // do_RTL should have been called once first to initialise all variables
\par // returns true with RTL has completed successfully
\par bool Copter::ModeAuto::verify_RTL()
\par \{
\par     return (copter.mode_rtl.state_complete() && (copter.mode_rtl.state() == RTL_FinalDescent || copter.mode_rtl.state() == RTL_Land));
\par \}
\par 
\par /********************************************************************************/
\par // Verify Condition (May) commands
\par /********************************************************************************/
\par 
\par bool Copter::ModeAuto::verify_wait_delay()
\par \{
\par     if (millis() - condition_start > (uint32_t)MAX(condition_value,0)) \{
\par         condition_value = 0;
\par         return true;
\par     \}
\par     return false;
\par \}
\par 
\par bool Copter::ModeAuto::verify_within_distance()
\par \{
\par     if (wp_distance() < (uint32_t)MAX(condition_value,0)) \{
\par         condition_value = 0;
\par         return true;
\par     \}
\par     return false;
\par \}
\par 
\par // verify_yaw - return true if we have reached the desired heading
\par bool Copter::ModeAuto::verify_yaw()
\par \{
\par     // set yaw mode if it has been changed (the waypoint controller often retakes control of yaw as it executes a new waypoint command)
\par     if (auto_yaw.mode() != AUTO_YAW_FIXED) \{
\par         auto_yaw.set_mode(AUTO_YAW_FIXED);
\par     \}
\par 
\par     // check if we are within 2 degrees of the target heading
\par     return (labs(wrap_180_cd(ahrs.yaw_sensor-auto_yaw.yaw())) <= 200);
\par \}
\par 
\par // verify_nav_wp - check if we have reached the next way point
\par bool Copter::ModeAuto::verify_nav_wp(const AP_Mission::Mission_Command& cmd)
\par \{
\par     // check if we have reached the waypoint
\par     if( !copter.wp_nav->reached_wp_destination() ) \{
\par         return false;
\par     \}
\par 
\par     // play a tone
\par     AP_Notify::events.waypoint_complete = 1;
\par 
\par     // start timer if necessary
\par     if(loiter_time == 0) \{
\par         loiter_time = millis();
\par     \}
\par 
\par     // check if timer has run out
\par     if (((millis() - loiter_time) / 1000) >= loiter_time_max) \{
\par         gcs().send_text(MAV_SEVERITY_INFO, "Reached command #%i",cmd.index);
\par         return true;
\par     \}else\{
\par         return false;
\par     \}
\par \}
\par 
\par 
\par 
\par // verify_circle - check if we have circled the point enough
\par bool Copter::ModeAuto::verify_circle(const AP_Mission::Mission_Command& cmd)
\par \{
\par     // check if we've reached the edge
\par     if (mode() == Auto_CircleMoveToEdge) \{
\par         if (copter.wp_nav->reached_wp_destination()) \{
\par             const Vector3f curr_pos = copter.inertial_nav.get_position();
\par             Vector3f circle_center = copter.pv_location_to_vector(cmd.content.location);
\par 
\par             // set target altitude if not provided
\par             if (is_zero(circle_center.z)) \{
\par                 circle_center.z = curr_pos.z;
\par             \}
\par 
\par             // set lat/lon position if not provided
\par             if (cmd.content.location.lat == 0 && cmd.content.location.lng == 0) \{
\par                 circle_center.x = curr_pos.x;
\par                 circle_center.y = curr_pos.y;
\par             \}
\par 
\par             // start circling
\par             circle_start();
\par         \}
\par         return false;
\par     \}
\par 
\par     // check if we have completed circling
\par     return fabsf(copter.circle_nav->get_angle_total()/M_2PI) >= LOWBYTE(cmd.p1);
\par \}
\par 
\par 
\par 
\par // verify_spline_wp - check if we have reached the next way point using spline
\par bool Copter::ModeAuto::verify_spline_wp(const AP_Mission::Mission_Command& cmd)
\par \{
\par     // check if we have reached the waypoint
\par     if( !copter.wp_nav->reached_wp_destination() ) \{
\par         return false;
\par     \}
\par 
\par     // start timer if necessary
\par     if(loiter_time == 0) \{
\par         loiter_time = millis();
\par     \}
\par 
\par     // check if timer has run out
\par     if (((millis() - loiter_time) / 1000) >= loiter_time_max) \{
\par         gcs().send_text(MAV_SEVERITY_INFO, "Reached command #%i",cmd.index);
\par         return true;
\par     \}else\{
\par         return false;
\par     \}
\par \}
\par 
\par #if NAV_GUIDED == ENABLED
\par // verify_nav_guided - check if we have breached any limits
\par bool Copter::ModeAuto::verify_nav_guided_enable(const AP_Mission::Mission_Command& cmd)
\par \{
\par     // if disabling guided mode then immediately return true so we move to next command
\par     if (cmd.p1 == 0) \{
\par         return true;
\par     \}
\par 
\par     // check time and position limits
\par     return copter.mode_guided.limit_check();
\par \}
\par #endif  // NAV_GUIDED
\par 
\par // verify_nav_delay - check if we have waited long enough
\par bool Copter::ModeAuto::verify_nav_delay(const AP_Mission::Mission_Command& cmd)
\par \{
\par     if (millis() - nav_delay_time_start > (uint32_t)MAX(nav_delay_time_max,0)) \{
\par         nav_delay_time_max = 0;
\par         return true;
\par     }{\rtlch\fcs1 \af31507 \ltrch\fcs0 \lang1033\langfe1033\langnp1033\insrsid15410912\charrsid7607385 \}
\par     return false;
\par \}
\par 
\par #endif
\par 
\par 
\par }{\rtlch\fcs1 \af31507 \ltrch\fcs0 \lang1033\langfe1033\highlight7\langnp1033\insrsid15410912\charrsid7607385 
\par }{\*\themedata 504b030414000600080000002100e9de0fbfff0000001c020000130000005b436f6e74656e745f54797065735d2e786d6cac91cb4ec3301045f748fc83e52d4a
9cb2400825e982c78ec7a27cc0c8992416c9d8b2a755fbf74cd25442a820166c2cd933f79e3be372bd1f07b5c3989ca74aaff2422b24eb1b475da5df374fd9ad
5689811a183c61a50f98f4babebc2837878049899a52a57be670674cb23d8e90721f90a4d2fa3802cb35762680fd800ecd7551dc18eb899138e3c943d7e503b6
b01d583deee5f99824e290b4ba3f364eac4a430883b3c092d4eca8f946c916422ecab927f52ea42b89a1cd59c254f919b0e85e6535d135a8de20f20b8c12c3b0
0c895fcf6720192de6bf3b9e89ecdbd6596cbcdd8eb28e7c365ecc4ec1ff1460f53fe813d3cc7f5b7f020000ffff0300504b030414000600080000002100a5d6
a7e7c0000000360100000b0000005f72656c732f2e72656c73848fcf6ac3300c87ef85bd83d17d51d2c31825762fa590432fa37d00e1287f68221bdb1bebdb4f
c7060abb0884a4eff7a93dfeae8bf9e194e720169aaa06c3e2433fcb68e1763dbf7f82c985a4a725085b787086a37bdbb55fbc50d1a33ccd311ba548b6309512
0f88d94fbc52ae4264d1c910d24a45db3462247fa791715fd71f989e19e0364cd3f51652d73760ae8fa8c9ffb3c330cc9e4fc17faf2ce545046e37944c69e462
a1a82fe353bd90a865aad41ed0b5b8f9d6fd010000ffff0300504b0304140006000800000021006b799616830000008a0000001c0000007468656d652f746865
6d652f7468656d654d616e616765722e786d6c0ccc4d0ac3201040e17da17790d93763bb284562b2cbaebbf600439c1a41c7a0d29fdbd7e5e38337cedf14d59b
4b0d592c9c070d8a65cd2e88b7f07c2ca71ba8da481cc52c6ce1c715e6e97818c9b48d13df49c873517d23d59085adb5dd20d6b52bd521ef2cdd5eb9246a3d8b
4757e8d3f729e245eb2b260a0238fd010000ffff0300504b030414000600080000002100a7259ef29c070000cb200000160000007468656d652f7468656d652f
7468656d65312e786d6cec59cd8b1bc915bf07f23f347d97f5d5ad8fc1f2a24fcfda33b6b164873dd648a5eef2547789aad28cc56208de532e81c026e49085bd
ed21842cecc22eb9e48f31d8249b3f22afaa5bdd5552c99e191c3061463074977eefd5afde7bf5de53d5ddcf5e26d4bbc05c1096f6fcfa9d9aefe174ce16248d
7afeb3d9a4d2f13d2151ba4094a5b8e76fb0f03fbbf7eb5fdd454732c609f6403e1547a8e7c752ae8eaa5531876124eeb0154ee1bb25e30992f0caa3ea82a34b
d09bd06aa3566b55134452df4b51026a6720e32db0f778b92473ecdfdbaa1f53982395420dcc299f2ae5389731b08bf3ba42888d1852ee5d20daf361a605bb9c
e197d2f7281212bee8f935fde757efddada2a35c88ca03b286dc44ffe572b9c0e2bca1e7e4d1593169108441ab5fe8d7002af771e3f6b8356e15fa3400cde7b0
d28c8badb3dd180639d600658f0edda3f6a859b7f086fee61ee77ea83e165e8332fdc11e7e321982152dbc0665f8700f1f0eba8391ad5f83327c6b0fdfaef547
41dbd2af413125e9f91eba16b69ac3ed6a0bc892d16327bc1b06937623575ea2201a8ae852532c592a0fc55a825e303e018002522449eac9cd0a2fd11ce27888
2839e3c43b21510c81b7422913305c6bd426b526fc579f403f698fa2238c0c69c50b9888bd21c5c713734e56b2e73f00adbe0179fbf3cf6f5efff8e6f54f6fbe
faeacdebbfe7736b5596dc314a2353ee97effef09f6f7eebfdfb876f7ff9fa8fd9d4bb7861e2dffded77effef1cff7a9871597a678fba7efdffdf8fddb3ffffe
5f7ffddaa1bdcfd199099f91040bef11bef49eb20416e8e08fcff8f524663122a6443f8d044a919ac5a17f2c630bfd68832872e006d8b6e3730ea9c605bcbf7e
61119ec67c2d8943e3c338b180a78cd101e34e2b3c547319669eadd3c83d395f9bb8a7085db8e61ea2d4f2f278bd821c4b5c2a8731b6683ea1289528c229969e
fa8e9d63ec58dd178458763d2573ce045b4aef0be20d10719a6446ceac682a858e49027ed9b80882bf2ddb9c3ef7068cba563dc2173612f606a20ef2334c2d33
de476b891297ca194aa869f013246317c9e986cf4ddc5848f0748429f3c60b2c844be63187f51a4e7f0869c6edf653ba496c2497e4dca5f30431662247ec7c18
a364e5c24e491a9bd8cfc5398428f29e30e9829f327b87a877f0034a0fbafb39c196bb3f9c0d9e418635299501a2be5973872fef6366c5ef74439708bb524d9f
27568aed73e28c8ec13ab242fb04638a2ed10263efd9e70e0603b6b26c5e927e10435639c6aec07a80ec5855ef2916d8d3cdcd7e9e3c21c20ad9298ed8013ea7
9b9dc4b3416982f821cd8fc0eba6cdc750ea1257003ca6f37313f888401708f1e234ca63013a8ce03ea8f5498cac02a6de853b5e37dcf2df55f618eccb17168d
2bec4b90c1d79681c46ecabcd7363344ad09ca809921e8325ce916442cf79722aab86ab1b5536e696fdad20dd01d594d4f42d20f76403bbd4ff8bfeb7da0c378
fb976f1c9bede3f43b6ec556b2ba66a77328991ceff4378770bb5dcd90f105f9f49b9a115aa74f30d491fd8c75dbd3dcf634feff7d4f73683fdf763287fa8ddb
4ec6870ee3b693c90f573e4e2753362fd0d7a8038feca0471ffb24074f7d9684d2a9dc507c22f4c18f80df338b090c2a397de6898b53c0550c8faaccc104162e
e248cb789cc9df10194f63b482d3a1baaf944422571d096fc5041c1ae961a76e85a7ebe4942db2c3ce7a5d1d6c66955520598ed7c2621c0eaa64866eb5cb03bc
42bd661be983d62d01257b1d12c6643689a683447b3ba88ca48f75c1680e127a651f8545d7c1a2a3d46f5db5c702a8155e811fdc1efc4ceff96100222004e771
d09c2f949f32576fbdab9df9313d7dc89856044083bd8d80d2d35dc5f5e0f2d4eab250bb82a72d1246b8d924b46574832762f8199c47a71abd0a8debfaba5bba
d4a2a74ca1e783d02a69b43bef6371535f83dc6e6ea0a9992968ea5df6fc5633849099a355cf5fc2a1313c262b881da17e73211ac1ddcb5cf26cc3df24b3acb8
902324e2cce03ae964d9202112738f92a4e7abe5176ea0a9ce219a5bbd0109e19325d785b4f2a99103a7db4ec6cb259e4bd3edc688b274f60a193ecb15ce6fb5
f8cdc14a92adc1ddd37871e99dd1357f8a20c4c2765d19704104dc1dd4336b2e085c861589ac8cbf9dc294a75df3364ac750368ee82a46794531937906d7a9bc
a0a3df0a1b186ff99ac1a08649f2427816a9026b1ad5aaa645d5c8381cacba1f1652963392665933adaca2aaa63b8b59336ccbc08e2d6f56e40d565b13434e33
2b7c96ba77536e779beb76fa84a24a80c10bfb39aaee150a8241ad9ccca2a618efa76195b3f351bb766c17f8016a57291246d66f6dd5eed8ada811cee960f046
951fe476a3168696dbbe525b5adf9b9b17dbecec05248f1174b96b2a8576255c5b73040dd154f72459da802df252e65b039ebc35273dffcb5ad80f868d7058a9
75c271256806b54a27ec372bfd306cd6c761bd361a345e41619171520fb33bfb095c60d04d7e73afc7f76eef93ed1dcd9d394baa4cdfca5735717d7b5f6f58b7
f7d94dbc375397f3be4720e97cd96a4cbacdeea055e936fb934a301a742add616b5019b586edd164340c3bddc92bdfbbd0e0a0df1c06ad71a7d2aa0f8795a055
53f43bdd4a3b6834fa41bbdf1907fd57791b032bcfd2476e0b30afe675efbf000000ffff0300504b0304140006000800000021000dd1909fb60000001b010000
270000007468656d652f7468656d652f5f72656c732f7468656d654d616e616765722e786d6c2e72656c73848f4d0ac2301484f78277086f6fd3ba109126dd88
d0add40384e4350d363f2451eced0dae2c082e8761be9969bb979dc9136332de3168aa1a083ae995719ac16db8ec8e4052164e89d93b64b060828e6f37ed1567
914b284d262452282e3198720e274a939cd08a54f980ae38a38f56e422a3a641c8bbd048f7757da0f19b017cc524bd62107bd5001996509affb3fd381a89672f
1f165dfe514173d9850528a2c6cce0239baa4c04ca5bbabac4df000000ffff0300504b01022d0014000600080000002100e9de0fbfff0000001c020000130000
0000000000000000000000000000005b436f6e74656e745f54797065735d2e786d6c504b01022d0014000600080000002100a5d6a7e7c0000000360100000b00
000000000000000000000000300100005f72656c732f2e72656c73504b01022d00140006000800000021006b799616830000008a0000001c0000000000000000
0000000000190200007468656d652f7468656d652f7468656d654d616e616765722e786d6c504b01022d0014000600080000002100a7259ef29c070000cb2000
001600000000000000000000000000d60200007468656d652f7468656d652f7468656d65312e786d6c504b01022d00140006000800000021000dd1909fb60000
001b0100002700000000000000000000000000a60a00007468656d652f7468656d652f5f72656c732f7468656d654d616e616765722e786d6c2e72656c73504b050600000000050005005d010000a10b00000000}
{\*\colorschememapping 3c3f786d6c2076657273696f6e3d22312e302220656e636f64696e673d225554462d3822207374616e64616c6f6e653d22796573223f3e0d0a3c613a636c724d
617020786d6c6e733a613d22687474703a2f2f736368656d61732e6f70656e786d6c666f726d6174732e6f72672f64726177696e676d6c2f323030362f6d6169
6e22206267313d226c743122207478313d22646b3122206267323d226c743222207478323d22646b322220616363656e74313d22616363656e74312220616363
656e74323d22616363656e74322220616363656e74333d22616363656e74332220616363656e74343d22616363656e74342220616363656e74353d22616363656e74352220616363656e74363d22616363656e74362220686c696e6b3d22686c696e6b2220666f6c486c696e6b3d22666f6c486c696e6b222f3e}
{\*\latentstyles\lsdstimax375\lsdlockeddef0\lsdsemihiddendef0\lsdunhideuseddef0\lsdqformatdef0\lsdprioritydef99{\lsdlockedexcept \lsdqformat1 \lsdpriority0 \lsdlocked0 Normal;\lsdqformat1 \lsdpriority9 \lsdlocked0 heading 1;
\lsdsemihidden1 \lsdunhideused1 \lsdqformat1 \lsdpriority9 \lsdlocked0 heading 2;\lsdsemihidden1 \lsdunhideused1 \lsdqformat1 \lsdpriority9 \lsdlocked0 heading 3;\lsdsemihidden1 \lsdunhideused1 \lsdqformat1 \lsdpriority9 \lsdlocked0 heading 4;
\lsdsemihidden1 \lsdunhideused1 \lsdqformat1 \lsdpriority9 \lsdlocked0 heading 5;\lsdsemihidden1 \lsdunhideused1 \lsdqformat1 \lsdpriority9 \lsdlocked0 heading 6;\lsdsemihidden1 \lsdunhideused1 \lsdqformat1 \lsdpriority9 \lsdlocked0 heading 7;
\lsdsemihidden1 \lsdunhideused1 \lsdqformat1 \lsdpriority9 \lsdlocked0 heading 8;\lsdsemihidden1 \lsdunhideused1 \lsdqformat1 \lsdpriority9 \lsdlocked0 heading 9;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 index 1;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 index 2;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 index 3;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 index 4;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 index 5;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 index 6;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 index 7;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 index 8;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 index 9;
\lsdsemihidden1 \lsdunhideused1 \lsdpriority39 \lsdlocked0 toc 1;\lsdsemihidden1 \lsdunhideused1 \lsdpriority39 \lsdlocked0 toc 2;\lsdsemihidden1 \lsdunhideused1 \lsdpriority39 \lsdlocked0 toc 3;
\lsdsemihidden1 \lsdunhideused1 \lsdpriority39 \lsdlocked0 toc 4;\lsdsemihidden1 \lsdunhideused1 \lsdpriority39 \lsdlocked0 toc 5;\lsdsemihidden1 \lsdunhideused1 \lsdpriority39 \lsdlocked0 toc 6;
\lsdsemihidden1 \lsdunhideused1 \lsdpriority39 \lsdlocked0 toc 7;\lsdsemihidden1 \lsdunhideused1 \lsdpriority39 \lsdlocked0 toc 8;\lsdsemihidden1 \lsdunhideused1 \lsdpriority39 \lsdlocked0 toc 9;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Normal Indent;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 footnote text;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 annotation text;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 header;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 footer;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 index heading;\lsdsemihidden1 \lsdunhideused1 \lsdqformat1 \lsdpriority35 \lsdlocked0 caption;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 table of figures;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 envelope address;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 envelope return;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 footnote reference;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 annotation reference;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 line number;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 page number;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 endnote reference;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 endnote text;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 table of authorities;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 macro;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 toa heading;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List Bullet;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List Number;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List 2;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List 3;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List 4;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List 5;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List Bullet 2;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List Bullet 3;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List Bullet 4;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List Bullet 5;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List Number 2;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List Number 3;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List Number 4;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List Number 5;\lsdqformat1 \lsdpriority10 \lsdlocked0 Title;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Closing;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Signature;\lsdsemihidden1 \lsdunhideused1 \lsdpriority1 \lsdlocked0 Default Paragraph Font;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Body Text;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Body Text Indent;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List Continue;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List Continue 2;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List Continue 3;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List Continue 4;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List Continue 5;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Message Header;\lsdqformat1 \lsdpriority11 \lsdlocked0 Subtitle;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Salutation;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Date;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Body Text First Indent;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Body Text First Indent 2;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Note Heading;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Body Text 2;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Body Text 3;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Body Text Indent 2;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Body Text Indent 3;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Block Text;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Hyperlink;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 FollowedHyperlink;\lsdqformat1 \lsdpriority22 \lsdlocked0 Strong;
\lsdqformat1 \lsdpriority20 \lsdlocked0 Emphasis;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Document Map;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Plain Text;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 E-mail Signature;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 HTML Top of Form;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 HTML Bottom of Form;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Normal (Web);\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 HTML Acronym;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 HTML Address;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 HTML Cite;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 HTML Code;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 HTML Definition;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 HTML Keyboard;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 HTML Preformatted;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 HTML Sample;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 HTML Typewriter;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 HTML Variable;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Normal Table;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 annotation subject;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 No List;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Outline List 1;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Outline List 2;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Outline List 3;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table Simple 1;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table Simple 2;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table Simple 3;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table Classic 1;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table Classic 2;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table Classic 3;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table Classic 4;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table Colorful 1;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table Colorful 2;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table Colorful 3;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table Columns 1;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table Columns 2;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table Columns 3;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table Columns 4;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table Columns 5;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table Grid 1;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table Grid 2;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table Grid 3;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table Grid 4;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table Grid 5;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table Grid 6;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table Grid 7;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table Grid 8;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table List 1;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table List 2;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table List 3;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table List 4;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table List 5;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table List 6;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table List 7;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table List 8;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table 3D effects 1;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table 3D effects 2;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table 3D effects 3;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table Contemporary;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table Elegant;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table Professional;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table Subtle 1;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table Subtle 2;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table Web 1;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table Web 2;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table Web 3;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Balloon Text;\lsdpriority39 \lsdlocked0 Table Grid;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Table Theme;\lsdsemihidden1 \lsdlocked0 Placeholder Text;
\lsdqformat1 \lsdpriority1 \lsdlocked0 No Spacing;\lsdpriority60 \lsdlocked0 Light Shading;\lsdpriority61 \lsdlocked0 Light List;\lsdpriority62 \lsdlocked0 Light Grid;\lsdpriority63 \lsdlocked0 Medium Shading 1;\lsdpriority64 \lsdlocked0 Medium Shading 2;
\lsdpriority65 \lsdlocked0 Medium List 1;\lsdpriority66 \lsdlocked0 Medium List 2;\lsdpriority67 \lsdlocked0 Medium Grid 1;\lsdpriority68 \lsdlocked0 Medium Grid 2;\lsdpriority69 \lsdlocked0 Medium Grid 3;\lsdpriority70 \lsdlocked0 Dark List;
\lsdpriority71 \lsdlocked0 Colorful Shading;\lsdpriority72 \lsdlocked0 Colorful List;\lsdpriority73 \lsdlocked0 Colorful Grid;\lsdpriority60 \lsdlocked0 Light Shading Accent 1;\lsdpriority61 \lsdlocked0 Light List Accent 1;
\lsdpriority62 \lsdlocked0 Light Grid Accent 1;\lsdpriority63 \lsdlocked0 Medium Shading 1 Accent 1;\lsdpriority64 \lsdlocked0 Medium Shading 2 Accent 1;\lsdpriority65 \lsdlocked0 Medium List 1 Accent 1;\lsdsemihidden1 \lsdlocked0 Revision;
\lsdqformat1 \lsdpriority34 \lsdlocked0 List Paragraph;\lsdqformat1 \lsdpriority29 \lsdlocked0 Quote;\lsdqformat1 \lsdpriority30 \lsdlocked0 Intense Quote;\lsdpriority66 \lsdlocked0 Medium List 2 Accent 1;\lsdpriority67 \lsdlocked0 Medium Grid 1 Accent 1;
\lsdpriority68 \lsdlocked0 Medium Grid 2 Accent 1;\lsdpriority69 \lsdlocked0 Medium Grid 3 Accent 1;\lsdpriority70 \lsdlocked0 Dark List Accent 1;\lsdpriority71 \lsdlocked0 Colorful Shading Accent 1;\lsdpriority72 \lsdlocked0 Colorful List Accent 1;
\lsdpriority73 \lsdlocked0 Colorful Grid Accent 1;\lsdpriority60 \lsdlocked0 Light Shading Accent 2;\lsdpriority61 \lsdlocked0 Light List Accent 2;\lsdpriority62 \lsdlocked0 Light Grid Accent 2;\lsdpriority63 \lsdlocked0 Medium Shading 1 Accent 2;
\lsdpriority64 \lsdlocked0 Medium Shading 2 Accent 2;\lsdpriority65 \lsdlocked0 Medium List 1 Accent 2;\lsdpriority66 \lsdlocked0 Medium List 2 Accent 2;\lsdpriority67 \lsdlocked0 Medium Grid 1 Accent 2;\lsdpriority68 \lsdlocked0 Medium Grid 2 Accent 2;
\lsdpriority69 \lsdlocked0 Medium Grid 3 Accent 2;\lsdpriority70 \lsdlocked0 Dark List Accent 2;\lsdpriority71 \lsdlocked0 Colorful Shading Accent 2;\lsdpriority72 \lsdlocked0 Colorful List Accent 2;\lsdpriority73 \lsdlocked0 Colorful Grid Accent 2;
\lsdpriority60 \lsdlocked0 Light Shading Accent 3;\lsdpriority61 \lsdlocked0 Light List Accent 3;\lsdpriority62 \lsdlocked0 Light Grid Accent 3;\lsdpriority63 \lsdlocked0 Medium Shading 1 Accent 3;\lsdpriority64 \lsdlocked0 Medium Shading 2 Accent 3;
\lsdpriority65 \lsdlocked0 Medium List 1 Accent 3;\lsdpriority66 \lsdlocked0 Medium List 2 Accent 3;\lsdpriority67 \lsdlocked0 Medium Grid 1 Accent 3;\lsdpriority68 \lsdlocked0 Medium Grid 2 Accent 3;\lsdpriority69 \lsdlocked0 Medium Grid 3 Accent 3;
\lsdpriority70 \lsdlocked0 Dark List Accent 3;\lsdpriority71 \lsdlocked0 Colorful Shading Accent 3;\lsdpriority72 \lsdlocked0 Colorful List Accent 3;\lsdpriority73 \lsdlocked0 Colorful Grid Accent 3;\lsdpriority60 \lsdlocked0 Light Shading Accent 4;
\lsdpriority61 \lsdlocked0 Light List Accent 4;\lsdpriority62 \lsdlocked0 Light Grid Accent 4;\lsdpriority63 \lsdlocked0 Medium Shading 1 Accent 4;\lsdpriority64 \lsdlocked0 Medium Shading 2 Accent 4;\lsdpriority65 \lsdlocked0 Medium List 1 Accent 4;
\lsdpriority66 \lsdlocked0 Medium List 2 Accent 4;\lsdpriority67 \lsdlocked0 Medium Grid 1 Accent 4;\lsdpriority68 \lsdlocked0 Medium Grid 2 Accent 4;\lsdpriority69 \lsdlocked0 Medium Grid 3 Accent 4;\lsdpriority70 \lsdlocked0 Dark List Accent 4;
\lsdpriority71 \lsdlocked0 Colorful Shading Accent 4;\lsdpriority72 \lsdlocked0 Colorful List Accent 4;\lsdpriority73 \lsdlocked0 Colorful Grid Accent 4;\lsdpriority60 \lsdlocked0 Light Shading Accent 5;\lsdpriority61 \lsdlocked0 Light List Accent 5;
\lsdpriority62 \lsdlocked0 Light Grid Accent 5;\lsdpriority63 \lsdlocked0 Medium Shading 1 Accent 5;\lsdpriority64 \lsdlocked0 Medium Shading 2 Accent 5;\lsdpriority65 \lsdlocked0 Medium List 1 Accent 5;\lsdpriority66 \lsdlocked0 Medium List 2 Accent 5;
\lsdpriority67 \lsdlocked0 Medium Grid 1 Accent 5;\lsdpriority68 \lsdlocked0 Medium Grid 2 Accent 5;\lsdpriority69 \lsdlocked0 Medium Grid 3 Accent 5;\lsdpriority70 \lsdlocked0 Dark List Accent 5;\lsdpriority71 \lsdlocked0 Colorful Shading Accent 5;
\lsdpriority72 \lsdlocked0 Colorful List Accent 5;\lsdpriority73 \lsdlocked0 Colorful Grid Accent 5;\lsdpriority60 \lsdlocked0 Light Shading Accent 6;\lsdpriority61 \lsdlocked0 Light List Accent 6;\lsdpriority62 \lsdlocked0 Light Grid Accent 6;
\lsdpriority63 \lsdlocked0 Medium Shading 1 Accent 6;\lsdpriority64 \lsdlocked0 Medium Shading 2 Accent 6;\lsdpriority65 \lsdlocked0 Medium List 1 Accent 6;\lsdpriority66 \lsdlocked0 Medium List 2 Accent 6;
\lsdpriority67 \lsdlocked0 Medium Grid 1 Accent 6;\lsdpriority68 \lsdlocked0 Medium Grid 2 Accent 6;\lsdpriority69 \lsdlocked0 Medium Grid 3 Accent 6;\lsdpriority70 \lsdlocked0 Dark List Accent 6;\lsdpriority71 \lsdlocked0 Colorful Shading Accent 6;
\lsdpriority72 \lsdlocked0 Colorful List Accent 6;\lsdpriority73 \lsdlocked0 Colorful Grid Accent 6;\lsdqformat1 \lsdpriority19 \lsdlocked0 Subtle Emphasis;\lsdqformat1 \lsdpriority21 \lsdlocked0 Intense Emphasis;
\lsdqformat1 \lsdpriority31 \lsdlocked0 Subtle Reference;\lsdqformat1 \lsdpriority32 \lsdlocked0 Intense Reference;\lsdqformat1 \lsdpriority33 \lsdlocked0 Book Title;\lsdsemihidden1 \lsdunhideused1 \lsdpriority37 \lsdlocked0 Bibliography;
\lsdsemihidden1 \lsdunhideused1 \lsdqformat1 \lsdpriority39 \lsdlocked0 TOC Heading;\lsdpriority41 \lsdlocked0 Plain Table 1;\lsdpriority42 \lsdlocked0 Plain Table 2;\lsdpriority43 \lsdlocked0 Plain Table 3;\lsdpriority44 \lsdlocked0 Plain Table 4;
\lsdpriority45 \lsdlocked0 Plain Table 5;\lsdpriority40 \lsdlocked0 Grid Table Light;\lsdpriority46 \lsdlocked0 Grid Table 1 Light;\lsdpriority47 \lsdlocked0 Grid Table 2;\lsdpriority48 \lsdlocked0 Grid Table 3;\lsdpriority49 \lsdlocked0 Grid Table 4;
\lsdpriority50 \lsdlocked0 Grid Table 5 Dark;\lsdpriority51 \lsdlocked0 Grid Table 6 Colorful;\lsdpriority52 \lsdlocked0 Grid Table 7 Colorful;\lsdpriority46 \lsdlocked0 Grid Table 1 Light Accent 1;\lsdpriority47 \lsdlocked0 Grid Table 2 Accent 1;
\lsdpriority48 \lsdlocked0 Grid Table 3 Accent 1;\lsdpriority49 \lsdlocked0 Grid Table 4 Accent 1;\lsdpriority50 \lsdlocked0 Grid Table 5 Dark Accent 1;\lsdpriority51 \lsdlocked0 Grid Table 6 Colorful Accent 1;
\lsdpriority52 \lsdlocked0 Grid Table 7 Colorful Accent 1;\lsdpriority46 \lsdlocked0 Grid Table 1 Light Accent 2;\lsdpriority47 \lsdlocked0 Grid Table 2 Accent 2;\lsdpriority48 \lsdlocked0 Grid Table 3 Accent 2;
\lsdpriority49 \lsdlocked0 Grid Table 4 Accent 2;\lsdpriority50 \lsdlocked0 Grid Table 5 Dark Accent 2;\lsdpriority51 \lsdlocked0 Grid Table 6 Colorful Accent 2;\lsdpriority52 \lsdlocked0 Grid Table 7 Colorful Accent 2;
\lsdpriority46 \lsdlocked0 Grid Table 1 Light Accent 3;\lsdpriority47 \lsdlocked0 Grid Table 2 Accent 3;\lsdpriority48 \lsdlocked0 Grid Table 3 Accent 3;\lsdpriority49 \lsdlocked0 Grid Table 4 Accent 3;
\lsdpriority50 \lsdlocked0 Grid Table 5 Dark Accent 3;\lsdpriority51 \lsdlocked0 Grid Table 6 Colorful Accent 3;\lsdpriority52 \lsdlocked0 Grid Table 7 Colorful Accent 3;\lsdpriority46 \lsdlocked0 Grid Table 1 Light Accent 4;
\lsdpriority47 \lsdlocked0 Grid Table 2 Accent 4;\lsdpriority48 \lsdlocked0 Grid Table 3 Accent 4;\lsdpriority49 \lsdlocked0 Grid Table 4 Accent 4;\lsdpriority50 \lsdlocked0 Grid Table 5 Dark Accent 4;
\lsdpriority51 \lsdlocked0 Grid Table 6 Colorful Accent 4;\lsdpriority52 \lsdlocked0 Grid Table 7 Colorful Accent 4;\lsdpriority46 \lsdlocked0 Grid Table 1 Light Accent 5;\lsdpriority47 \lsdlocked0 Grid Table 2 Accent 5;
\lsdpriority48 \lsdlocked0 Grid Table 3 Accent 5;\lsdpriority49 \lsdlocked0 Grid Table 4 Accent 5;\lsdpriority50 \lsdlocked0 Grid Table 5 Dark Accent 5;\lsdpriority51 \lsdlocked0 Grid Table 6 Colorful Accent 5;
\lsdpriority52 \lsdlocked0 Grid Table 7 Colorful Accent 5;\lsdpriority46 \lsdlocked0 Grid Table 1 Light Accent 6;\lsdpriority47 \lsdlocked0 Grid Table 2 Accent 6;\lsdpriority48 \lsdlocked0 Grid Table 3 Accent 6;
\lsdpriority49 \lsdlocked0 Grid Table 4 Accent 6;\lsdpriority50 \lsdlocked0 Grid Table 5 Dark Accent 6;\lsdpriority51 \lsdlocked0 Grid Table 6 Colorful Accent 6;\lsdpriority52 \lsdlocked0 Grid Table 7 Colorful Accent 6;
\lsdpriority46 \lsdlocked0 List Table 1 Light;\lsdpriority47 \lsdlocked0 List Table 2;\lsdpriority48 \lsdlocked0 List Table 3;\lsdpriority49 \lsdlocked0 List Table 4;\lsdpriority50 \lsdlocked0 List Table 5 Dark;
\lsdpriority51 \lsdlocked0 List Table 6 Colorful;\lsdpriority52 \lsdlocked0 List Table 7 Colorful;\lsdpriority46 \lsdlocked0 List Table 1 Light Accent 1;\lsdpriority47 \lsdlocked0 List Table 2 Accent 1;\lsdpriority48 \lsdlocked0 List Table 3 Accent 1;
\lsdpriority49 \lsdlocked0 List Table 4 Accent 1;\lsdpriority50 \lsdlocked0 List Table 5 Dark Accent 1;\lsdpriority51 \lsdlocked0 List Table 6 Colorful Accent 1;\lsdpriority52 \lsdlocked0 List Table 7 Colorful Accent 1;
\lsdpriority46 \lsdlocked0 List Table 1 Light Accent 2;\lsdpriority47 \lsdlocked0 List Table 2 Accent 2;\lsdpriority48 \lsdlocked0 List Table 3 Accent 2;\lsdpriority49 \lsdlocked0 List Table 4 Accent 2;
\lsdpriority50 \lsdlocked0 List Table 5 Dark Accent 2;\lsdpriority51 \lsdlocked0 List Table 6 Colorful Accent 2;\lsdpriority52 \lsdlocked0 List Table 7 Colorful Accent 2;\lsdpriority46 \lsdlocked0 List Table 1 Light Accent 3;
\lsdpriority47 \lsdlocked0 List Table 2 Accent 3;\lsdpriority48 \lsdlocked0 List Table 3 Accent 3;\lsdpriority49 \lsdlocked0 List Table 4 Accent 3;\lsdpriority50 \lsdlocked0 List Table 5 Dark Accent 3;
\lsdpriority51 \lsdlocked0 List Table 6 Colorful Accent 3;\lsdpriority52 \lsdlocked0 List Table 7 Colorful Accent 3;\lsdpriority46 \lsdlocked0 List Table 1 Light Accent 4;\lsdpriority47 \lsdlocked0 List Table 2 Accent 4;
\lsdpriority48 \lsdlocked0 List Table 3 Accent 4;\lsdpriority49 \lsdlocked0 List Table 4 Accent 4;\lsdpriority50 \lsdlocked0 List Table 5 Dark Accent 4;\lsdpriority51 \lsdlocked0 List Table 6 Colorful Accent 4;
\lsdpriority52 \lsdlocked0 List Table 7 Colorful Accent 4;\lsdpriority46 \lsdlocked0 List Table 1 Light Accent 5;\lsdpriority47 \lsdlocked0 List Table 2 Accent 5;\lsdpriority48 \lsdlocked0 List Table 3 Accent 5;
\lsdpriority49 \lsdlocked0 List Table 4 Accent 5;\lsdpriority50 \lsdlocked0 List Table 5 Dark Accent 5;\lsdpriority51 \lsdlocked0 List Table 6 Colorful Accent 5;\lsdpriority52 \lsdlocked0 List Table 7 Colorful Accent 5;
\lsdpriority46 \lsdlocked0 List Table 1 Light Accent 6;\lsdpriority47 \lsdlocked0 List Table 2 Accent 6;\lsdpriority48 \lsdlocked0 List Table 3 Accent 6;\lsdpriority49 \lsdlocked0 List Table 4 Accent 6;
\lsdpriority50 \lsdlocked0 List Table 5 Dark Accent 6;\lsdpriority51 \lsdlocked0 List Table 6 Colorful Accent 6;\lsdpriority52 \lsdlocked0 List Table 7 Colorful Accent 6;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Mention;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Smart Hyperlink;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Hashtag;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Unresolved Mention;}}{\*\datastore 010500000200000018000000
4d73786d6c322e534158584d4c5265616465722e362e3000000000000000000000060000
d0cf11e0a1b11ae1000000000000000000000000000000003e000300feff090006000000000000000000000001000000010000000000000000100000feffffff00000000feffffff0000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
fffffffffffffffffdfffffffeffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffff52006f006f007400200045006e00740072007900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000016000500ffffffffffffffffffffffff0c6ad98892f1d411a65f0040963251e5000000000000000000000000002b
223944c3d401feffffff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffff00000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffff0000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffff000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000105000000000000}}